<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="d6/db5/md_binary_search__r_e_a_d_m_e" kind="page">
    <compoundname>md_binary_search_README</compoundname>
    <title>Overview of Binary Search</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect3 id="d6/db5/md_binary_search__r_e_a_d_m_e_1autotoc_md6">
<title>The concept of binary search algorithm</title>
<para>Binary search is a search algorithm that finds the poistion of a target value whithin a sorted array or data structure. Binary search compares the target value to the middle element of that array or data structure.</para>
</sect3>
<sect3 id="d6/db5/md_binary_search__r_e_a_d_m_e_1autotoc_md7">
<title>The concept of struct and class declarations</title>
<para>For C program, a struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence. (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps) Within a struct object, addresses of its elements increase in order in which the members were defined.</para>
<para>For C++ program, classes and structs are user-defined types, defined by class-specifier.</para>
</sect3>
<sect3 id="d6/db5/md_binary_search__r_e_a_d_m_e_1autotoc_md8">
<title>The concept of pointer and reference</title>
<para>A pointer is an object that stores the address, or location in memory, of some other object. That is, it is a reference to some other value. A pointer is a type of thing, the same way an integer or string is a type of thing. In addition, a pointer exist so that you can dereference it to set or get the addressed value.</para>
<para><preformatted><computeroutput>int x = 0;
int* px = 
*px = 42; // dereference px -&gt; x</computeroutput></preformatted></para>
<para>Reference is another value which eliminates nearly all the problems that come with pointers. It is still possible to mess up, but not easily.</para>
<para><preformatted><computeroutput>int x = -7;
int &amp; y = x;
y = 12; // exact same thing as x = 12;</computeroutput></preformatted></para>
<para>Note that if you can resolve the name inline then you can simply have both names for the same value in your symbol lookup table. (this is an excellent optimization!). Otherwise, you&apos;ll need to generate object code that actually used a pointer to do the dirty work.</para>
</sect3>
<sect3 id="d6/db5/md_binary_search__r_e_a_d_m_e_1autotoc_md9">
<title>The concept of Pass-by-value, Pass-by-reference and Pass-by-pointer</title>
<para>Pass-by-value: An argument passed by value is one where a value is copied into a special location in the computer&apos;s memory (called the &quot;stack frame&quot;). This location is special because the function has a name for it, and you can use that name to access the (local copy of the) value.</para>
<para><preformatted><computeroutput>void by_value(int x)
{
    x+= 1; // 8
}

int <ref refid="d5/dbb/priority__queue_2_c_make_files_23_819_86_2_compiler_id_c_2_c_make_c_compiler_id_8c_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>
{
    int z = 7; 
    by_value(z); // 7
}</computeroutput></preformatted></para>
<para>Pass-by-pointer: An argument passed by pointer is where a pointer value is copied into a special location in the computer&apos;s memory (called the &quot;stack frame&quot;). This local pointer can be dereferenced to access(and modify) the referent value.</para>
<para><preformatted><computeroutput>void by_pointer(int* x)
{
    *x += 1; // 8
}

int <ref refid="d5/dbb/priority__queue_2_c_make_files_23_819_86_2_compiler_id_c_2_c_make_c_compiler_id_8c_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>
{
    int z = 7;
    by_pointer( &amp;z ); // 8
}</computeroutput></preformatted></para>
<para>Pass-by-reference: An argument passed by reference is where the formal argument (the name) is an alias for the actual argument (the value).</para>
<para><preformatted><computeroutput>void by_reference(int &amp; x)
{
    x += 1; // 8
}

int <ref refid="d5/dbb/priority__queue_2_c_make_files_23_819_86_2_compiler_id_c_2_c_make_c_compiler_id_8c_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>
{
    int z = 7;
    by_reference(z); // 8
}
</computeroutput></preformatted></para>
<para>Note that some people dislike the term pass-by-pointer. They feel it is misleading and inexact, since the actual argument to the function is a pointer value (an address) which is passed by value into function. Hence, they say this is really pass-by-value.</para>
</sect3>
<sect3 id="d6/db5/md_binary_search__r_e_a_d_m_e_1autotoc_md10">
<title>Reference</title>
<para>[1] <ulink url="https://en.cppreference.com/w/c/language/struct">cppreference: Struct declaration</ulink></para>
<para>[2] <ulink url="https://en.cppreference.com/w/cpp/language/class">cppreference: Class declaration</ulink></para>
<para>[3] <ulink url="https://en.cppreference.com/w/c/language/union">cppreference: Union declaration</ulink></para>
<para>[4] <ulink url="https://en.wikipedia.org/wiki/Binary_search_algorithm">Wiki: Binary search algorithm</ulink></para>
<para>[5] <ulink url="https://www.cplusplus.com/faq/beginners/call-by/">cplusplus: Pass-by-value vs Pass-by-reference</ulink></para>
<para>[6] <ulink url="https://www.cplusplus.com/faq/beginners/pointers-and-references/">cplusplus: Pointer and References</ulink> </para>
</sect3>
    </detaileddescription>
    <location file="binary_search/README.md"/>
  </compounddef>
</doxygen>
