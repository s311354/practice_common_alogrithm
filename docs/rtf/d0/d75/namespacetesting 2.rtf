{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
testing Namespace Reference\par \pard\plain 
{\tc\tcl2 \v testing}
{\xe \v testing}
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b anonymous_namespace\{gtest-printers.cc\}}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b anonymous_namespace\{gtest.cc\}}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b internal2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EmptyTestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Environment}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Message}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedFakeTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestEventListeners}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResultArray}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResultReporterInterface}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestProperty}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTest}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Environment} * {\b AddGlobalTestEnvironment} ({\b Environment} *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int kSize> {\b std::vector}< {\b std::string} > {\b ArrayAsVector} (const char *const (&array)[kSize])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b AssertionFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b AssertionFailure} (const {\b Message} &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b AssertionSuccess} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b DoubleLE} (const char *expr1, const char *expr2, double val1, double val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b FloatLE} (const char *expr1, const char *expr2, float val1, float val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b FormatCountableNoun} (int count, const char *singular_form, const char *plural_form)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b FormatTestCaseCount} (int test_case_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b FormatTestCount} (int test_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b FormatWordList} (const {\b std::vector}< {\b std::string} > &words)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b GetDefaultFilter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::vector}< {\b std::string} > {\b GetReservedAttributesForElement} (const {\b std::string} &xml_element)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (also_run_disabled_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (break_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (catch_exceptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (death_test_use_fork)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (list_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (print_time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (show_internal_stack_frames)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (shuffle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (throw_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (random_seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (repeat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (stack_trace_depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (death_test_style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (filter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (stream_result_to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (also_run_disabled_tests, {\b internal::BoolFromGTestEnv}("also_run_disabled_tests", false), "Run disabled tests too, in addition to the tests normally being run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (break_on_failure, {\b internal::BoolFromGTestEnv}("break_on_failure", false), "True iff a failed assertion should be a debugger break-point.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (catch_exceptions, {\b internal::BoolFromGTestEnv}("catch_exceptions", true), "True iff " GTEST_NAME_ " should catch exceptions and treat them as test failures.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (death_test_use_fork, {\b internal::BoolFromGTestEnv}("death_test_use_fork", false), "Instructs to use fork()/_exit() instead of clone() in death tests. " "Ignored and always uses fork() on POSIX systems where clone() is not " "implemented. Useful when running under valgrind or similar tools if " "those do not support clone(). Valgrind 3.3.1 will just fail if " "it sees an unsupported combination of clone() flags. " "It is not recommended to use this flag w/o valgrind though it will " "work in 99% of the cases. Once valgrind is fixed, this flag will " "most likely be removed.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (list_tests, false, "List all tests without running them.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (print_time, {\b internal::BoolFromGTestEnv}("print_time", true), "True iff " GTEST_NAME_ " should display elapsed time in text output.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (show_internal_stack_frames, false, "True iff " GTEST_NAME_ " should include internal stack frames when " "printing test failure stack traces.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (shuffle, {\b internal::BoolFromGTestEnv}("shuffle", false), "True iff " GTEST_NAME_ " should randomize tests' order on every run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (throw_on_failure, {\b internal::BoolFromGTestEnv}("throw_on_failure", false), "When this flag is specified, a failed assertion will throw an exception " "if exceptions are enabled or exit the program with a non-zero code " "otherwise.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (random_seed, {\b internal::Int32FromGTestEnv}("random_seed", 0), "Random number seed to use when shuffling test orders.  Must be in range " "[1, 99999], or 0 to use a seed based on the current time.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (repeat, {\b internal::Int32FromGTestEnv}("repeat", 1), "How many times to repeat each test.  Specify a negative number " "for repeating forever.  Useful for shaking out flaky tests.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (stack_trace_depth, {\b internal::Int32FromGTestEnv}("stack_trace_depth", kMaxStackTraceDepth), "The maximum number of stack frames to print when an " "assertion fails.  The valid range is 0 through 100, inclusive.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (color, {\b internal::StringFromGTestEnv}("color", "auto"), "Whether to use colors in the output.  Valid values: yes, no, " "and auto.  'auto' means to use colors if the output is " "being sent to a terminal and the TERM environment variable " "is set to a terminal type that supports colors.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (death_test_style, {\b internal::StringFromGTestEnv}("death_test_style", kDefaultDeathTestStyle), "Indicates how to run a death test in a forked child process: " "\\"threadsafe\\" (child process re-executes the test binary " "from the beginning, running only the specific death test) or " "\\"fast\\" (child process runs the death test immediately " "after forking).")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (filter, {\b internal::StringFromGTestEnv}("filter", GetDefaultFilter()), "A colon-separated list of glob (not regex) patterns " "for filtering the tests to run, optionally followed by a " "'-' and a : separated list of negative patterns (tests to " "exclude).  A test is run if it matches one of the positive " "patterns and does not match any of the negative patterns.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (output, {\b internal::StringFromGTestEnv}("output", ""), "A format (currently must be \\"xml\\"), optionally followed " "by a colon and an output file name or directory. A directory " "is indicated by a trailing pathname separator. " "Examples: \\"xml:filename.xml\\", \\"xml::directoryname/\\". " "If a directory is specified, output files will be created " "within that directory, with file-names based on the test " "executable's name and, if necessary, made unique by adding " "digits.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (stream_result_to, {\b internal::StringFromGTestEnv}("stream_result_to", ""), "This flag specifies the host name and the port number on which to stream " "test results. Example: \\"localhost:555\\". The flag is effective only on " "Linux.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitGoogleTest} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitGoogleTest} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const ::{\b std::string} &needle, const ::{\b std::string} &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const ::{\b std::string} &needle, const ::{\b std::string} &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::ostream} & {\b operator<<} ({\b std::ostream} &os, const {\b Message} &sb)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::ostream} & {\b operator<<} ({\b std::ostream} &os, const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > ::{\b std::string} {\b PrintToString} (const T &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > bool {\b StaticAssertTypeEq} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b TestPartFatallyFailed} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b TestPartNonfatallyFailed} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b TestPartResultTypeToString} ({\b TestPartResult::Type} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ValidateTestPropertyName} (const {\b std::string} &property_name, const {\b std::vector}< {\b std::string} > &reserved_names)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constants\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __pad0__}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kDeathTestCaseFilter} [] = "*DeathTest:*DeathTest/*"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kDefaultDeathTestStyle} [] = "fast"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kDefaultOutputFile} [] = "test_detail.xml"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kDisableTestFilter} [] = "DISABLED_*:*/DISABLED_*"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kMaxStackTraceDepth} = 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char *const {\b kReservedTestCaseAttributes} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char *const {\b kReservedTestSuiteAttributes} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char *const {\b kReservedTestSuitesAttributes} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kTestShardIndex} [] = "GTEST_SHARD_INDEX"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kTestShardStatusFile} [] = "GTEST_SHARD_STATUS_FILE"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kTestTotalShards} [] = "GTEST_TOTAL_SHARDS"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kUniversalFilter} [] = "*"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v AddGlobalTestEnvironment\:testing}
{\xe \v testing\:AddGlobalTestEnvironment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Environment}* testing::AddGlobalTestEnvironment ({\b Environment} *  {\i env}){\f2 [package]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1350                                                                \{\par
1351   {\cf19 return} UnitTest::GetInstance()->AddEnvironment(env);\par
1352 \}\par
}
}
{\xe \v ArrayAsVector\:testing}
{\xe \v testing\:ArrayAsVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int kSize> {\b std::vector}<{\b std::string}> testing::ArrayAsVector (const char *const (&)  {\i array}[kSize])}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2108                                                                       \{\par
2109   {\cf19 return} std::vector<std::string>(array, array + kSize);\par
2110 \}\par
}
{
\ql
Referenced by GetReservedAttributesForElement().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a956d4c522454fa6dfd75b5bbbefe8f9e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v AssertionFailure\:testing}
{\xe \v testing\:AssertionFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::AssertionFailure ()}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1015                                    \{\par
1016   {\cf19 return} AssertionResult({\cf17 false});\par
1017 \}\par
}
{
\ql
Referenced by AssertionFailure(), AssertPred1Helper(), AssertPred2Helper(), AssertPred3Helper(), AssertPred4Helper(), AssertPred5Helper(), testing::internal::CmpHelperOpFailure(), testing::internal::CmpHelperSTRCASENE(), testing::internal::CmpHelperSTRNE(), testing::internal::DoubleNearPredFormat(), testing::internal::EqFailure(), testing::internal::FloatingPointLE(), testing::internal::HasOneFailure(), and testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a8d91083190a5914bfe8c5666e2dbca9b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v AssertionFailure\:testing}
{\xe \v testing\:AssertionFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::AssertionFailure (const {\b Message} &  {\i message})}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1021                                                          \{\par
1022   {\cf19 return} AssertionFailure() << message;\par
1023 \}\par
}
{
\ql
References AssertionFailure().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a37b4cce49a6850c1f06772de1940c28d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v AssertionSuccess\:testing}
{\xe \v testing\:AssertionSuccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::AssertionSuccess ()}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1010                                    \{\par
1011   {\cf19 return} AssertionResult({\cf17 true});\par
1012 \}\par
}
{
\ql
Referenced by AssertPred1Helper(), AssertPred2Helper(), AssertPred3Helper(), AssertPred4Helper(), AssertPred5Helper(), testing::internal::CmpHelperEQ(), testing::internal::CmpHelperFloatingPointEQ(), testing::internal::CmpHelperSTRCASEEQ(), testing::internal::CmpHelperSTRCASENE(), testing::internal::CmpHelperSTREQ(), testing::internal::CmpHelperSTRNE(), testing::internal::DoubleNearPredFormat(), testing::internal::FloatingPointLE(), testing::internal::HasOneFailure(), and testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a74a3d26c1286bd4d7c189c5dff2483ab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DoubleLE\:testing}
{\xe \v testing\:DoubleLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::DoubleLE (const char *  {\i expr1}, const char *  {\i expr2}, double  {\i val1}, double  {\i val2})}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1429                                                    \{\par
1430   {\cf19 return} internal::FloatingPointLE<double>(expr1, expr2, val1, val2);\par
1431 \}\par
}
}
{\xe \v FloatLE\:testing}
{\xe \v testing\:FloatLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::FloatLE (const char *  {\i expr1}, const char *  {\i expr2}, float  {\i val1}, float  {\i val2})}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1422                                                 \{\par
1423   {\cf19 return} internal::FloatingPointLE<float>(expr1, expr2, val1, val2);\par
1424 \}\par
}
}
{\xe \v FormatCountableNoun\:testing}
{\xe \v testing\:FormatCountableNoun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::FormatCountableNoun (int  {\i count}, const char *  {\i singular_form}, const char *  {\i plural_form}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2811                                                                  \{\par
2812   {\cf19 return} internal::StreamableToString(count) + {\cf22 " "} +\par
2813       (count == 1 ? singular_form : plural_form);\par
2814 \}\par
}
{
\ql
References testing::internal::StreamableToString().}\par
{
\ql
Referenced by FormatTestCaseCount(), FormatTestCount(), testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd(), and testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a33e070c3e994cb75f9017fa2a044d536_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a33e070c3e994cb75f9017fa2a044d536_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatTestCaseCount\:testing}
{\xe \v testing\:FormatTestCaseCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::FormatTestCaseCount (int  {\i test_case_count}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2822                                                           \{\par
2823   {\cf19 return} FormatCountableNoun(test_case_count, {\cf22 "test case"}, {\cf22 "test cases"});\par
2824 \}\par
}
{
\ql
References FormatCountableNoun().}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(), and testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_ab8cabb45f3d8c52d336372c1b62d75c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_ab8cabb45f3d8c52d336372c1b62d75c5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatTestCount\:testing}
{\xe \v testing\:FormatTestCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::FormatTestCount (int  {\i test_count}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2817                                                  \{\par
2818   {\cf19 return} FormatCountableNoun(test_count, {\cf22 "test"}, {\cf22 "tests"});\par
2819 \}\par
}
{
\ql
References FormatCountableNoun().}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(), and testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a7420a0eb48a02ba210e265afb75febdf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a7420a0eb48a02ba210e265afb75febdf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatWordList\:testing}
{\xe \v testing\:FormatWordList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::FormatWordList (const {\b std::vector}< {\b std::string} > &  {\i words}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2127                                                                    \{\par
2128   Message word_list;\par
2129   {\cf19 for} ({\cf18 size_t} i = 0; i < words.size(); ++i) \{\par
2130     {\cf19 if} (i > 0 && words.size() > 2) \{\par
2131       word_list << {\cf22 ", "};\par
2132     \}\par
2133     {\cf19 if} (i == words.size() - 1) \{\par
2134       word_list << {\cf22 "and "};\par
2135     \}\par
2136     word_list << {\cf22 "'"} << words[i] << {\cf22 "'"};\par
2137   \}\par
2138   {\cf19 return} word_list.GetString();\par
2139 \}\par
}
{
\ql
References testing::Message::GetString(), and std::vector< T >::size().}\par
{
\ql
Referenced by ValidateTestPropertyName().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a4354761948a5cf56fdf905418a0f78f1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a4354761948a5cf56fdf905418a0f78f1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetDefaultFilter\:testing}
{\xe \v testing\:GetDefaultFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* testing::GetDefaultFilter (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 192                                       \{\par
193 {\cf21 #ifdef GTEST_TEST_FILTER_ENV_VAR_}\par
194   {\cf17 const} {\cf18 char}* {\cf17 const} testbridge_test_only = getenv(GTEST_TEST_FILTER_ENV_VAR_);\par
195   {\cf19 if} (testbridge_test_only != NULL) \{\par
196     {\cf19 return} testbridge_test_only;\par
197   \}\par
198 {\cf21 #endif  }{\cf20 // GTEST_TEST_FILTER_ENV_VAR_}\par
199   {\cf19 return} kUniversalFilter;\par
200 \}\par
}
{
\ql
References kUniversalFilter.}\par
}
{\xe \v GetReservedAttributesForElement\:testing}
{\xe \v testing\:GetReservedAttributesForElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::vector}<{\b std::string}> testing::GetReservedAttributesForElement (const {\b std::string} &  {\i xml_element}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2113                                   \{\par
2114   {\cf19 if} (xml_element == {\cf22 "testsuites"}) \{\par
2115     {\cf19 return} ArrayAsVector(kReservedTestSuitesAttributes);\par
2116   \} {\cf19 else} {\cf19 if} (xml_element == {\cf22 "testsuite"}) \{\par
2117     {\cf19 return} ArrayAsVector(kReservedTestSuiteAttributes);\par
2118   \} {\cf19 else} {\cf19 if} (xml_element == {\cf22 "testcase"}) \{\par
2119     {\cf19 return} ArrayAsVector(kReservedTestCaseAttributes);\par
2120   \} {\cf19 else} \{\par
2121     GTEST_CHECK_({\cf17 false}) << {\cf22 "Unrecognized xml_element provided: "} << xml_element;\par
2122   \}\par
2123   {\cf20 // This code is unreachable but some compilers may not realizes that.}\par
2124   {\cf19 return} std::vector<std::string>();\par
2125 \}\par
}
{
\ql
References ArrayAsVector(), GTEST_CHECK_, kReservedTestCaseAttributes, kReservedTestSuiteAttributes, and kReservedTestSuitesAttributes.}\par
{
\ql
Referenced by testing::internal::XmlUnitTestResultPrinter::OutputXmlAttribute(), and testing::TestResult::ValidateTestProperty().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_acb3fdfadf475a3c2f5e22a3dae73532a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_acb3fdfadf475a3c2f5e22a3dae73532a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (also_run_disabled_tests )}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (break_on_failure )}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (catch_exceptions )}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (death_test_use_fork )}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (list_tests )}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (print_time )}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (show_internal_stack_frames )}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (shuffle )}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (throw_on_failure )}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (random_seed )}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (repeat )}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (stack_trace_depth )}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (color )}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (death_test_style )}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (filter )}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (output )}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (stream_result_to )}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (also_run_disabled_tests , {\b internal::BoolFromGTestEnv}("also_run_disabled_tests", false) , "Run disabled tests  {\i too}, in addition to the tests normally being run." )}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (break_on_failure , {\b internal::BoolFromGTestEnv}("break_on_failure", false) , "True iff a failed assertion should be a debugger break-point." )}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (catch_exceptions , {\b internal::BoolFromGTestEnv}("catch_exceptions", true) , "True iff " GTEST_NAME_ " should catch exceptions and treat them as test failures." )}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (death_test_use_fork , {\b internal::BoolFromGTestEnv}("death_test_use_fork", false) , "Instructs to use fork()/_exit() instead of clone() in death tests. " "Ignored and always uses fork() on POSIX systems where clone() is not " "implemented. Useful when running under valgrind or similar tools if " "those do not support clone(). Valgrind 3.3.1 will just fail if " "it sees an unsupported combination of clone() flags. " "It is not recommended to use this flag w/o valgrind though it will " "work in 99% of the cases. Once valgrind is  {\i fixed}, this flag will " "most likely be removed." )}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (list_tests , false , "List all tests without running them." )}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (print_time , {\b internal::BoolFromGTestEnv}("print_time", true) , "True iff " GTEST_NAME_ " should display elapsed time in text output." )}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (show_internal_stack_frames , false , "True iff " GTEST_NAME_ " should include internal stack frames when " "printing test failure stack traces." )}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (shuffle , {\b internal::BoolFromGTestEnv}("shuffle", false) , "True iff " GTEST_NAME_ " should randomize tests' order on every run." )}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (throw_on_failure , {\b internal::BoolFromGTestEnv}("throw_on_failure", false) , "When this flag is  {\i specified}, a failed assertion will throw an exception " "if exceptions are enabled or exit the program with a non-zero code " "otherwise." )}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (random_seed , {\b internal::Int32FromGTestEnv}("random_seed", 0) , "Random number seed to use when shuffling test orders. Must be in range " " [1, 99999], or 0 to use a seed based on the current time." )}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (repeat , {\b internal::Int32FromGTestEnv}("repeat", 1) , "How many times to repeat each test. Specify a negative number " "for repeating forever. Useful for shaking out flaky tests." )}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (stack_trace_depth , {\b internal::Int32FromGTestEnv}("stack_trace_depth", kMaxStackTraceDepth) , "The maximum number of stack frames to print when an " "assertion fails. The valid range is 0 through  {\i 100}, inclusive." )}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (color , {\b internal::StringFromGTestEnv}("color", "auto") , "Whether to use colors in the output. Valid values:  {\i yes}, no , " "and auto. 'auto' means to use colors if the output is " "being sent to a terminal and the TERM environment variable " "is set to a terminal type that supports colors." )}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (death_test_style , {\b internal::StringFromGTestEnv}("death_test_style", kDefaultDeathTestStyle) , "Indicates how to run a death test in a forked child process: " "\\"threadsafe\\" (child process re-executes the test binary " "from the beginning, running only the specific death test) or " "\\"fast\\" (child process runs the death test immediately " "after forking)." )}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (filter , {\b internal::StringFromGTestEnv}("filter", GetDefaultFilter()) , "A colon-separated list of glob (not regex) patterns " "for filtering the tests to  {\i run}, optionally followed by a " "'-' and a :separated list of negative patterns(tests to " "exclude). A test is run if it matches one of the positive " "patterns and does not match any of the negative patterns." )}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (output , {\b internal::StringFromGTestEnv}("output", "") , "A format  currently must be \\"xml\\", optionally followed " "by a colon and an output file name or directory. A directory " "is indicated by a trailing pathname separator. " "Examples:\\"xml:filename.xml\\" , \\"xml::directoryname/\\". " "If a directory is  {\i specified}, output files will be created " "within that  {\i directory}, with file-names based on the test " "executable 's name  {\i and}, if  {\i necessary}, made unique by adding " "digits." )}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (stream_result_to , {\b internal::StringFromGTestEnv}("stream_result_to", "") , "This flag specifies the host name and the port number on which to stream " "test results. Example: \\"localhost:555\\". The flag is effective only on " "Linux." )}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v InitGoogleTest\:testing}
{\xe \v testing\:InitGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::InitGoogleTest (int *  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5370                                             \{\par
5371 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5372   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
5373 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5374   internal::InitGoogleTestImpl(argc, argv);\par
5375 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5376 \}\par
}
{
\ql
References testing::internal::InitGoogleTestImpl().}\par
{
\ql
Referenced by main().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_aee3f6f99df893f576f705f66c0559482_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_aee3f6f99df893f576f705f66c0559482_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v InitGoogleTest\:testing}
{\xe \v testing\:InitGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::InitGoogleTest (int *  {\i argc}, wchar_t **  {\i argv})}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5380                                                \{\par
5381 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5382   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
5383 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5384   internal::InitGoogleTestImpl(argc, argv);\par
5385 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
5386 \}\par
}
{
\ql
References testing::internal::InitGoogleTestImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a6e9d83553f1d10818d698d45689d8adb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const ::{\b std::string} &  {\i needle}, const ::{\b std::string} &  {\i haystack})}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1638                                                         \{\par
1639   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
1640 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a645d822e47dc64b9923e78c880807f12_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const char *  {\i needle}, const char *  {\i haystack})}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1620                                               \{\par
1621   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
1622 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_ab553b649b06ef2339cbd90f8dfa119f0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const wchar_t *  {\i needle}, const wchar_t *  {\i haystack})}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1626                                                     \{\par
1627   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
1628 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a28868925c50d541c8568a540b6457e54_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const ::{\b std::string} &  {\i needle}, const ::{\b std::string} &  {\i haystack})}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1632                                                         \{\par
1633   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
1634 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a32718fab95b2833ab5ffc9cfc9f5c8b0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const char *  {\i needle}, const char *  {\i haystack})}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1608                                               \{\par
1609   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
1610 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a5c90a86562b2470213c07742e0eeb0fe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const wchar_t *  {\i needle}, const wchar_t *  {\i haystack})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1614                                                     \{\par
1615   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
1616 \}\par
}
{
\ql
References testing::anonymous_namespace\{gtest.cc\}::IsSubstringImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a08ce65847491b27a38cbac3ac15e3035_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<<\:testing}
{\xe \v testing\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::ostream}& testing::operator<< ({\b std::ostream} &  {\i os}, const {\b Message} &  {\i sb})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 232                                                                   \{\par
233   {\cf19 return} os << sb.GetString();\par
234 \}\par
}
{
\ql
References testing::Message::GetString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a7b802e532fd68749765cb7dc156130db_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<<\:testing}
{\xe \v testing\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::ostream} & testing::operator<< ({\b std::ostream} &  {\i os}, const {\b TestPartResult} &  {\i result})}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                                                      \{\par
59   {\cf19 return} os\par
60       << result.file_name() << {\cf22 ":"} << result.line_number() << {\cf22 ": "}\par
61       << (result.type() == TestPartResult::kSuccess ? {\cf22 "Success"} :\par
62           result.type() == TestPartResult::kFatalFailure ? {\cf22 "Fatal failure"} :\par
63           {\cf22 "Non-fatal failure"}) << {\cf22 ":\\n"}\par
64       << result.message() << std::endl;\par
65 \}\par
}
{
\ql
References std::endl(), testing::TestPartResult::file_name(), testing::TestPartResult::kFatalFailure, testing::TestPartResult::kSuccess, testing::TestPartResult::line_number(), testing::TestPartResult::message(), and testing::TestPartResult::type().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a7c88897836b9f492190fb2b9dfa3a327_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintToString\:testing}
{\xe \v testing\:PrintToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > ::{\b std::string} testing::PrintToString (const T &  {\i value})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 980                                         \{\par
981   ::std::stringstream ss;\par
982   internal::UniversalTersePrinter<T>::Print(value, &ss);\par
983   {\cf19 return} ss.str();\par
984 \}\par
}
{
\ql
References testing::internal::UniversalTersePrinter< T >::Print(), and std::stringstream::str().}\par
{
\ql
Referenced by testing::internal::CmpHelperSTRCASEEQ(), testing::internal::CmpHelperSTREQ(), testing::internal::CmpHelperSTRNE(), and testing::internal::FormatForComparison< ToPrint, OtherOperand >::Format().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_aa5717bb1144edd1d262d310ba70c82ed_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_aa5717bb1144edd1d262d310ba70c82ed_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v StaticAssertTypeEq\:testing}
{\xe \v testing\:StaticAssertTypeEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > bool testing::StaticAssertTypeEq (){\f2 [package]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2150                           \{\par
2151   (void)internal::StaticAssertTypeEqHelper<T1, T2>();\par
2152   {\cf19 return} {\cf17 true};\par
2153 \}\par
}
}
{\xe \v TestPartFatallyFailed\:testing}
{\xe \v testing\:TestPartFatallyFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::TestPartFatallyFailed (const {\b TestPartResult} &  {\i result}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2179                                                                 \{\par
2180   {\cf19 return} result.fatally_failed();\par
2181 \}\par
}
{
\ql
References testing::TestPartResult::fatally_failed().}\par
{
\ql
Referenced by testing::TestResult::HasFatalFailure().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a9f19442d566c7eaec0702b9fcf282b63_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a9f19442d566c7eaec0702b9fcf282b63_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TestPartNonfatallyFailed\:testing}
{\xe \v testing\:TestPartNonfatallyFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::TestPartNonfatallyFailed (const {\b TestPartResult} &  {\i result}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2189                                                                    \{\par
2190   {\cf19 return} result.nonfatally_failed();\par
2191 \}\par
}
{
\ql
References testing::TestPartResult::nonfatally_failed().}\par
{
\ql
Referenced by testing::TestResult::HasNonfatalFailure().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_af256d104ca665115eb291f762bb659e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_af256d104ca665115eb291f762bb659e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TestPartResultTypeToString\:testing}
{\xe \v testing\:TestPartResultTypeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* testing::TestPartResultTypeToString ({\b TestPartResult::Type}  {\i type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2830                                                                         \{\par
2831   {\cf19 switch} (type) \{\par
2832     {\cf19 case} TestPartResult::kSuccess:\par
2833       {\cf19 return} {\cf22 "Success"};\par
2834 \par
2835     {\cf19 case} TestPartResult::kNonFatalFailure:\par
2836     {\cf19 case} TestPartResult::kFatalFailure:\par
2837 {\cf21 #ifdef _MSC_VER}\par
2838       {\cf19 return} {\cf22 "error: "};\par
2839 {\cf21 #else}\par
2840       {\cf19 return} {\cf22 "Failure\\n"};\par
2841 {\cf21 #endif}\par
2842     {\cf19 default}:\par
2843       {\cf19 return} {\cf22 "Unknown result type"};\par
2844   \}\par
2845 \}\par
}
{
\ql
References testing::TestPartResult::kFatalFailure, testing::TestPartResult::kNonFatalFailure, and testing::TestPartResult::kSuccess.}\par
{
\ql
Referenced by testing::internal::PrintTestPartResultToString().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a4e9fdeef31f7e49afccfde0532f76864_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ValidateTestPropertyName\:testing}
{\xe \v testing\:ValidateTestPropertyName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::ValidateTestPropertyName (const {\b std::string} &  {\i property_name}, const {\b std::vector}< {\b std::string} > &  {\i reserved_names})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2142                                                                           \{\par
2143   {\cf19 if} (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=\par
2144           reserved_names.end()) \{\par
2145     ADD_FAILURE() << {\cf22 "Reserved key used in RecordProperty(): "} << property_name\par
2146                   << {\cf22 " ("} << FormatWordList(reserved_names)\par
2147                   << {\cf22 " are reserved by "} << GTEST_NAME_ << {\cf22 ")"};\par
2148     {\cf19 return} {\cf17 false};\par
2149   \}\par
2150   {\cf19 return} {\cf17 true};\par
2151 \}\par
}
{
\ql
References ADD_FAILURE, std::vector< T >::begin(), std::vector< T >::end(), std::find(), FormatWordList(), and GTEST_NAME_.}\par
{
\ql
Referenced by testing::TestResult::ValidateTestProperty().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a4c9bd414747bf0563bfdb32a2307dcdf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d75/namespacetesting_a4c9bd414747bf0563bfdb32a2307dcdf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constant Documentation\par
\pard\plain 
{\xe \v __pad0__\:testing}
{\xe \v testing\:__pad0__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::__pad0__{\f2 [package]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kDeathTestCaseFilter\:testing}
{\xe \v testing\:kDeathTestCaseFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kDeathTestCaseFilter[] = "*DeathTest:*DeathTest/*"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::GetTestCase().}\par
}
{\xe \v kDefaultDeathTestStyle\:testing}
{\xe \v testing\:kDefaultDeathTestStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kDefaultDeathTestStyle[] = "fast"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kDefaultOutputFile\:testing}
{\xe \v testing\:kDefaultOutputFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kDefaultOutputFile[] = "test_detail.xml"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile().}\par
}
{\xe \v kDisableTestFilter\:testing}
{\xe \v testing\:kDisableTestFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::FilterTests().}\par
}
{\xe \v kMaxStackTraceDepth\:testing}
{\xe \v testing\:kMaxStackTraceDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::kMaxStackTraceDepth = 100}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kReservedTestCaseAttributes\:testing}
{\xe \v testing\:kReservedTestCaseAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* const testing::kReservedTestCaseAttributes[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  {\cf22 "classname"},\par
  {\cf22 "name"},\par
  {\cf22 "status"},\par
  {\cf22 "time"},\par
  {\cf22 "type_param"},\par
  {\cf22 "value_param"}\par
\}\par
}
{
\ql
Referenced by GetReservedAttributesForElement().}\par
}
{\xe \v kReservedTestSuiteAttributes\:testing}
{\xe \v testing\:kReservedTestSuiteAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* const testing::kReservedTestSuiteAttributes[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  {\cf22 "disabled"},\par
  {\cf22 "errors"},\par
  {\cf22 "failures"},\par
  {\cf22 "name"},\par
  {\cf22 "tests"},\par
  {\cf22 "time"}\par
\}\par
}
{
\ql
Referenced by GetReservedAttributesForElement().}\par
}
{\xe \v kReservedTestSuitesAttributes\:testing}
{\xe \v testing\:kReservedTestSuitesAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* const testing::kReservedTestSuitesAttributes[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  {\cf22 "disabled"},\par
  {\cf22 "errors"},\par
  {\cf22 "failures"},\par
  {\cf22 "name"},\par
  {\cf22 "random_seed"},\par
  {\cf22 "tests"},\par
  {\cf22 "time"},\par
  {\cf22 "timestamp"}\par
\}\par
}
{
\ql
Referenced by GetReservedAttributesForElement().}\par
}
{\xe \v kTestShardIndex\:testing}
{\xe \v testing\:kTestShardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kTestShardIndex[] = "GTEST_SHARD_INDEX"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::FilterTests(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(), testing::internal::UnitTestImpl::RunAllTests(), and testing::internal::ShouldShard().}\par
}
{\xe \v kTestShardStatusFile\:testing}
{\xe \v testing\:kTestShardStatusFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::WriteToShardStatusFileIfNeeded().}\par
}
{\xe \v kTestTotalShards\:testing}
{\xe \v testing\:kTestTotalShards}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kTestTotalShards[] = "GTEST_TOTAL_SHARDS"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::FilterTests(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(), testing::internal::UnitTestImpl::RunAllTests(), and testing::internal::ShouldShard().}\par
}
{\xe \v kUniversalFilter\:testing}
{\xe \v testing\:kUniversalFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::kUniversalFilter[] = "*"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestOptions::FilterMatchesTest(), GetDefaultFilter(), and testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart().}\par
}
}