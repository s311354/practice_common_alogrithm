{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
testing::internal Namespace Reference\par \pard\plain 
{\tc\tcl2 \v testing::internal}
{\xe \v testing::internal}
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b anonymous_namespace\{gtest.cc\}}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b edit_distance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b posix}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IteratorTraits< const T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b String}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize< 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize< 8 >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long long {\b BiggestInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b FloatingPoint}< double > {\b Double}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b bool_constant}< false > {\b false_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b FloatingPoint}< float > {\b Float}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 4 >::Int {\b Int32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::Int {\b Int64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b IsContainer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char {\b IsNotContainer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GTestMutexLock} {\b MutexLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b SetUpTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::{\b std::string} {\b string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::{\b std::vector}< {\b string} > {\b Strings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b TearDownTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::Int {\b TimeInMillis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b bool_constant}< true > {\b true_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const void * {\b TypeId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 4 >::UInt {\b UInt32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::UInt {\b UInt64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::{\b std::wstring} {\b wstring}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CharFormat} \{ {\b kAsIs}
, {\b kHexEscape}
, {\b kSpecialEscape}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GTestColor} \{ {\b COLOR_DEFAULT}
, {\b COLOR_RED}
, {\b COLOR_GREEN}
, {\b COLOR_YELLOW}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GTestLogSeverity} \{ {\b GTEST_INFO}
, {\b GTEST_WARNING}
, {\b GTEST_ERROR}
, {\b GTEST_FATAL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AlwaysFalse} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AlwaysTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b AppendUserMessage} (const {\b std::string} &gtest_msg, const {\b Message} &user_msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iter , typename Element > Iter {\b ArrayAwareFind} (Iter begin, Iter end, const Element &elem)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b ArrayEq} (const T &lhs, const U &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b ArrayEq} (const T *lhs, size_t size, const U *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> bool {\b ArrayEq} (const T(&lhs)[N], const U(&rhs)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b BoolFromGTestEnv} (const char *flag, bool default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b CaptureStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b CaptureStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Derived , class Base > Derived * {\b CheckedDowncastToActualType} (Base *base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt32} {\b ChopLowBits} ({\b UInt32} *bits, int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, {\b BiggestInt} lhs, {\b BiggestInt} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperEQFailure} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > {\b AssertionResult} {\b CmpHelperFloatingPointEQ} (const char *lhs_expression, const char *rhs_expression, RawType lhs_value, RawType rhs_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperOpFailure} (const char *expr1, const char *expr2, const T1 &val1, const T2 &val2, const char *op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTRCASEEQ} (const char *lhs_expression, const char *rhs_expression, const char *lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTRCASENE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTREQ} (const char *lhs_expression, const char *rhs_expression, const char *lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTREQ} (const char *lhs_expression, const char *rhs_expression, const wchar_t *lhs, const wchar_t *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b CodePointToUtf8} ({\b UInt32} code_point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ColoredPrintf} ({\b GTestColor} color, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b CopyArray} (const T &from, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b CopyArray} (const T *from, size_t size, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> void {\b CopyArray} (const T(&from)[N], U(*to)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Predicate > int {\b CountIf} (const Container &c, Predicate predicate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt32} {\b CreateCodePointFromUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > void {\b DefaultPrintTo} ({\b IsContainer}, {\b false_type}, const C &container, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintTo} ({\b IsNotContainer}, {\b false_type}, const T &value, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintTo} ({\b IsNotContainer}, {\b true_type}, T *p, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static void {\b Delete} (T *x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b DiffStrings} (const {\b std::string} &left, const {\b std::string} &right, size_t *total_line_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b DoubleNearPredFormat} (const char *expr1, const char *expr2, const char *abs_error_expr, double val1, double val2, double abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To , typename From > To {\b DownCast_} (From *f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b EqFailure} (const char *lhs_expression, const char *rhs_expression, const {\b std::string} &lhs_value, const {\b std::string} &rhs_value, bool ignoring_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b FlagToEnvVar} (const char *flag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > {\b AssertionResult} {\b FloatingPointLE} (const char *expr1, const char *expr2, RawType val1, RawType val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FlushInfoLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Functor > void {\b ForEach} (const Container &c, Functor functor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} ::{\b std::string} {\b FormatCompilerIndependentFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b FormatEpochTimeInMillisAsIso8601} ({\b TimeInMillis} ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} ::{\b std::string} {\b FormatFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b std::string} {\b FormatForComparisonFailureMessage} (const T1 &value, const T2 &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b FormatTimeInMillisAsSeconds} ({\b TimeInMillis} ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b GetAnsiColorCode} ({\b GTestColor} color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const ::{\b std::vector}< {\b testing::internal::string} > & {\b GetArgvs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b GetBoolAssertionFailureMessage} (const {\b AssertionResult} &assertion_result, const char *expression_text, const char *actual_predicate_value, const char *expected_predicate_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b GetCapturedStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b GetCapturedStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b FilePath} {\b GetCurrentExecutableName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b GetCurrentOsStackTraceExceptTop} ({\b UnitTest} *, int skip_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > E {\b GetElementOr} (const {\b std::vector}< E > &v, int i, E default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b GetFileSize} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetNextRandomSeed} (int seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetRandomSeedFromFlag} ({\b Int32} random_seed_flag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TypeId} {\b GetTestTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b GetThreadCount} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b TimeInMillis} {\b GetTimeInMillis} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b TypeId} {\b GetTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b std::string} {\b GetTypeName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnitTestImpl} * {\b GetUnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b GTEST_DECLARE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (internal_run_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b GTEST_DEFINE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (internal_run_death_test, "", "Indicates the file, line number, temporal index of " "the single death test to run, and a file descriptor to " "which a success code may be sent, all separated by " "the '|' characters.  This flag is specified if and only if the current " "process is a sub-process launched for running a thread-safe " "death test.  FOR INTERNAL USE ONLY.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (GE, >=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (GT, >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (LE,<=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (LT,<)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (NE, !=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (wchar_t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_STRING_} (char, ::{\b std::string})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b GTestIsInitialized} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b HandleExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b HandleSehExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b HasGoogleTestFlagPrefix} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b HasOneFailure} (const char *, const char *, const char *, const {\b TestPartResultArray} &results, {\b TestPartResult::Type} type, const {\b string} &substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To > To {\b ImplicitCast_} (To x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b InitGoogleTestImpl} (int *argc, CharType **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b Int32} {\b Int32FromEnvOrDie} (const char *env_var, {\b Int32} default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int32} {\b Int32FromGTestEnv} (const char *flag, {\b Int32} default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAlNum} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAlpha} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > {\b IsContainer} {\b IsContainerTest} (int, typename C::iterator *=NULL, typename C::const_iterator *=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > {\b IsNotContainer} {\b IsContainerTest} (long)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char(& {\b IsNullLiteralHelper} (...))[2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b IsNullLiteralHelper} (Secret *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b IsPathSeparator} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPrintableAscii} (wchar_t c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsSpace} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsTrue} (bool condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsXDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsXDigit} (wchar_t ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b LogToStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b linked_ptr}< T > {\b make_linked_ptr} (T *ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestInfo} * {\b MakeAndRegisterTestInfo} (const char *test_case_name, const char *name, const char *type_param, const char *value_param, {\b CodeLocation} code_location, {\b TypeId} fixture_class_id, {\b SetUpTestCaseFunc} set_up_tc, {\b TearDownTestCaseFunc} tear_down_tc, {\b TestFactoryBase} *factory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > const T & {\b move} (const T &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b operator!=} (T *ptr, const {\b linked_ptr}< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b operator==} (T *ptr, const {\b linked_ptr}< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseBoolFlag} (const char *str, const char *flag, bool *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ParseFlagValue} (const char *str, const char *flag, bool def_optional)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseGoogleTestFlag} (const char *const arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b ParseGoogleTestFlagsOnly} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b ParseGoogleTestFlagsOnly} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b ParseGoogleTestFlagsOnlyImpl} (int *argc, CharType **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseInt32} (const {\b Message} &src_text, const char *str, {\b Int32} *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ParseInt32Flag} (const char *str, const char *flag, {\b Int32} *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseStringFlag} (const char *str, const char *flag, {\b std::string} *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b PortableLocaltime} (time_t seconds, struct tm *out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UnsignedChar , typename Char > static {\b CharFormat} {\b PrintAsCharLiteralTo} (Char c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b CharFormat} {\b PrintAsStringLiteralTo} (char c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b CharFormat} {\b PrintAsStringLiteralTo} (wchar_t c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UnsignedChar , typename Char > void {\b PrintCharAndCodeTo} (Char c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > {\b GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_} {\b GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_} static {\b GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_} void {\b PrintCharsAsStringTo} (const CharType *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintColorEncoded} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintFullTestCommentIfPresent} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintOnOneLine} (const char *str, int max_length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b PrintRawArrayTo} (const T a[], size_t count, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintStringTo} (const ::{\b std::string} &s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintStringTo} (const ::{\b std::string} &s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintTestPartResult} (const {\b TestPartResult} &test_part_result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b std::string} {\b PrintTestPartResultToString} (const {\b TestPartResult} &test_part_result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (bool x, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (char c, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > void {\b PrintTo} (const ::{\b std::pair}< T1, T2 > &value, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const ::{\b std::string} &s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (const char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const char *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const signed char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b PrintTo} (const T &value, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const unsigned char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (const wchar_t *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const wchar_t *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (signed char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (signed char c, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (unsigned char *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (unsigned char c, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (wchar_t *s, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (wchar_t wc, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (wchar_t wc, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b ReadEntireFile} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReportFailureInUnknownLocation} ({\b TestPartResult::Type} result_type, const {\b std::string} &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b SetUpEnvironment} ({\b Environment} *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b ShouldRunTestCase} (const {\b TestCase} *test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldRunTestOnShard} (int total_shards, int shard_index, int test_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldShard} (const char *total_shards_str, const char *shard_index_str, bool in_subprocess_for_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldUseColor} (bool stdout_is_tty)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b Shuffle} ({\b internal::Random} *random, {\b std::vector}< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b ShuffleRange} ({\b internal::Random} *random, int begin, int end, {\b std::vector}< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SkipPrefix} (const char *prefix, const char **pstr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SplitString} (const ::{\b std::string} &str, char delimiter, ::{\b std::vector}< ::{\b std::string} > *dest)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b std::string} {\b StreamableToString} (const T &streamable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b StringFromGTestEnv} (const char *flag, const char *default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b StringStreamToString} (::{\b std::stringstream} *ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b StripTrailingSpaces} ({\b std::string} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b SumOverTestCaseList} (const {\b std::vector}< {\b TestCase} * > &case_list, int(TestCase::*method)() const)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b TearDownEnvironment} ({\b Environment} *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::string} {\b TempDir} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b TestCaseFailed} (const {\b TestCase} *test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b TestCasePassed} (const {\b TestCase} *test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ToLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ToUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalPrint} (const T &value, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b UniversalPrintArray} (const char *begin, size_t len, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UniversalPrintArray} (const char *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalPrintArray} (const T *begin, size_t len, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b UniversalPrintArray} (const wchar_t *begin, size_t len, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UniversalPrintArray} (const wchar_t *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > {\b GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_} {\b GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_} static {\b GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_} void {\b UniversalPrintCharArray} (const CharType *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalTersePrint} (const T &value, ::{\b std::ostream} *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b std::string} {\b WideStringToUtf8} (const wchar_t *str, int num_chars)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteToShardStatusFileIfNeeded} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constants\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::{\b std::vector}< {\b testing::internal::string} > {\b g_argvs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b g_help_flag} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::GTestFlagSaver} {\b GTEST_ATTRIBUTE_UNUSED_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kAlsoRunDisabledTestsFlag} [] = "also_run_disabled_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kBreakOnFailureFlag} [] = "break_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kCatchExceptionsFlag} [] = "catch_exceptions"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kColorEncodedHelpMessage} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kColorFlag} [] = "color"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kCurrentDirectoryString} [] = "./"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kDeathTestStyleFlag} [] = "death_test_style"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kDeathTestUseFork} [] = "death_test_use_fork"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kFilterFlag} [] = "filter"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kFlagfileFlag} [] = "flagfile"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kInternalRunDeathTestFlag} [] = "internal_run_death_test"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kListTestsFlag} [] = "list_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b BiggestInt} {\b kMaxBiggestInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint1} = (static_cast<{\b UInt32}>(1) << 7) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint2} = (static_cast<{\b UInt32}>(1) << (5 + 6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint3} = (static_cast<{\b UInt32}>(1) << (4 + 2*6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint4} = (static_cast<{\b UInt32}>(1) << (3 + 3*6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kMaxRandomSeed} = 99999\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kOutputFlag} [] = "output"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kPathSeparator} = '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kPrintTimeFlag} [] = "print_time"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kRandomSeedFlag} [] = "random_seed"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kRepeatFlag} [] = "repeat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kShuffleFlag} [] = "shuffle"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kStackTraceDepthFlag} [] = "stack_trace_depth"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kStackTraceMarker} [] = "\\nStack trace:\\n"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kStdErrFileno} = STDERR_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kStdOutFileno} = STDOUT_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kStreamResultToFlag} [] = "stream_result_to"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const {\b TypeId} {\b kTestTypeIdInGoogleTest} = {\b GetTestTypeId}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kThrowOnFailureFlag} [] = "throw_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kTypeParamLabel} [] = "TypeParam"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kUnknownFile} [] = "unknown file"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b kValueParamLabel} [] = "GetParam()"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Class Documentation\par
\pard\plain 
{\xe \v testing::internal::IteratorTraits< const T * >}
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
struct testing::internal::IteratorTraits< const T * >\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::IteratorTraits< const T * >\par
}

\par
}
Collaboration diagram for testing::internal::IteratorTraits< const T * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d9f/structtesting_1_1internal_1_1IteratorTraits_3_01const_01T_01_5_01_4__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Class Members:\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\qr typedef T{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
\cell }{value_type\cell }{\cell }{\row }
}
{\xe \v testing::internal::TypeWithSize}
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
class testing::internal::TypeWithSize\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<size_t size>\par
class testing::internal::TypeWithSize< size >\par
}

\par
}
Inheritance diagram for testing::internal::TypeWithSize< size >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d84/classtesting_1_1internal_1_1TypeWithSize__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for testing::internal::TypeWithSize< size >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d01/classtesting_1_1internal_1_1TypeWithSize__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Class Members:\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\qr typedef void{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\cell }{UInt\cell }{\cell }{\row }
}
{\xe \v testing::internal::TypeWithSize< 4 >}
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
class testing::internal::TypeWithSize< 4 >\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
Collaboration diagram for testing::internal::TypeWithSize< 4 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "db/d25/classtesting_1_1internal_1_1TypeWithSize_3_014_01_4__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Class Members:\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\qr typedef int{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\cell }{Int\cell }{\cell }{\row }
{\qr typedef unsigned int{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
\cell }{UInt\cell }{\cell }{\row }
}
{\xe \v testing::internal::TypeWithSize< 8 >}
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
class testing::internal::TypeWithSize< 8 >\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
Collaboration diagram for testing::internal::TypeWithSize< 8 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/de3/classtesting_1_1internal_1_1TypeWithSize_3_018_01_4__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Class Members:\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\qr typedef long long{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
\cell }{Int\cell }{\cell }{\row }
{\qr typedef unsigned long long{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\cell }{UInt\cell }{\cell }{\row }
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BiggestInt\:testing::internal}
{\xe \v testing::internal\:BiggestInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long long {\b testing::internal::BiggestInt}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Double\:testing::internal}
{\xe \v testing::internal\:Double}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b FloatingPoint}<double> {\b testing::internal::Double}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v false_type\:testing::internal}
{\xe \v testing::internal\:false_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b bool_constant}<false> {\b testing::internal::false_type}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Float\:testing::internal}
{\xe \v testing::internal\:Float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b FloatingPoint}<float> {\b testing::internal::Float}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Int32\:testing::internal}
{\xe \v testing::internal\:Int32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<4>::Int {\b testing::internal::Int32}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Int64\:testing::internal}
{\xe \v testing::internal\:Int64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::Int {\b testing::internal::Int64}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsContainer\:testing::internal}
{\xe \v testing::internal\:IsContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int {\b testing::internal::IsContainer}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsNotContainer\:testing::internal}
{\xe \v testing::internal\:IsNotContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char {\b testing::internal::IsNotContainer}}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MutexLock\:testing::internal}
{\xe \v testing::internal\:MutexLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GTestMutexLock} {\b testing::internal::MutexLock}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SetUpTestCaseFunc\:testing::internal}
{\xe \v testing::internal\:SetUpTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* testing::internal::SetUpTestCaseFunc) ()}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:testing::internal}
{\xe \v testing::internal\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::{\b std::string} {\b testing::internal::string}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Strings\:testing::internal}
{\xe \v testing::internal\:Strings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::{\b std::vector}<{\b string}> {\b testing::internal::Strings}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TearDownTestCaseFunc\:testing::internal}
{\xe \v testing::internal\:TearDownTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* testing::internal::TearDownTestCaseFunc) ()}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TimeInMillis\:testing::internal}
{\xe \v testing::internal\:TimeInMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::Int {\b testing::internal::TimeInMillis}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v true_type\:testing::internal}
{\xe \v testing::internal\:true_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b bool_constant}<true> {\b testing::internal::true_type}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TypeId\:testing::internal}
{\xe \v testing::internal\:TypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const void* {\b testing::internal::TypeId}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UInt32\:testing::internal}
{\xe \v testing::internal\:UInt32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<4>::UInt {\b testing::internal::UInt32}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UInt64\:testing::internal}
{\xe \v testing::internal\:UInt64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::UInt {\b testing::internal::UInt64}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v wstring\:testing::internal}
{\xe \v testing::internal\:wstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::{\b std::wstring} {\b testing::internal::wstring}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v CharFormat\:testing::internal}
{\xe \v testing::internal\:CharFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::CharFormat}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kAsIs\:testing::internal}
{\xe \v testing::internal\:kAsIs}
{\qr kAsIs{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
\cell }{\cell }{\row }
{\xe \v kHexEscape\:testing::internal}
{\xe \v testing::internal\:kHexEscape}
{\qr kHexEscape{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
\cell }{\cell }{\row }
{\xe \v kSpecialEscape\:testing::internal}
{\xe \v testing::internal\:kSpecialEscape}
{\qr kSpecialEscape{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128                 \{\par
129   kAsIs,\par
130   kHexEscape,\par
131   kSpecialEscape\par
132 \};\par
}
}
{\xe \v GTestColor\:testing::internal}
{\xe \v testing::internal\:GTestColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::GTestColor}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v COLOR_DEFAULT\:testing::internal}
{\xe \v testing::internal\:COLOR_DEFAULT}
{\qr COLOR_DEFAULT{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\cell }{\cell }{\row }
{\xe \v COLOR_RED\:testing::internal}
{\xe \v testing::internal\:COLOR_RED}
{\qr COLOR_RED{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
\cell }{\cell }{\row }
{\xe \v COLOR_GREEN\:testing::internal}
{\xe \v testing::internal\:COLOR_GREEN}
{\qr COLOR_GREEN{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
\cell }{\cell }{\row }
{\xe \v COLOR_YELLOW\:testing::internal}
{\xe \v testing::internal\:COLOR_YELLOW}
{\qr COLOR_YELLOW{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2880                 \{\par
2881   COLOR_DEFAULT,\par
2882   COLOR_RED,\par
2883   COLOR_GREEN,\par
2884   COLOR_YELLOW\par
2885 \};\par
}
}
{\xe \v GTestLogSeverity\:testing::internal}
{\xe \v testing::internal\:GTestLogSeverity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::GTestLogSeverity}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v GTEST_INFO\:testing::internal}
{\xe \v testing::internal\:GTEST_INFO}
{\qr GTEST_INFO{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
\cell }{\cell }{\row }
{\xe \v GTEST_WARNING\:testing::internal}
{\xe \v testing::internal\:GTEST_WARNING}
{\qr GTEST_WARNING{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
\cell }{\cell }{\row }
{\xe \v GTEST_ERROR\:testing::internal}
{\xe \v testing::internal\:GTEST_ERROR}
{\qr GTEST_ERROR{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
\cell }{\cell }{\row }
{\xe \v GTEST_FATAL\:testing::internal}
{\xe \v testing::internal\:GTEST_FATAL}
{\qr GTEST_FATAL{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1244                       \{\par
1245   GTEST_INFO,\par
1246   GTEST_WARNING,\par
1247   GTEST_ERROR,\par
1248   GTEST_FATAL\par
1249 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v AlwaysFalse\:testing::internal}
{\xe \v testing::internal\:AlwaysFalse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::AlwaysFalse ()}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 736 \{ {\cf19 return} !AlwaysTrue(); \}\par
}
{
\ql
References AlwaysTrue().}\par
{
\ql
Referenced by ColoredPrintf().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4b24c851ab13569b1b15b3d259b60d2e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4b24c851ab13569b1b15b3d259b60d2e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v AlwaysTrue\:testing::internal}
{\xe \v testing::internal\:AlwaysTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} bool testing::internal::AlwaysTrue ()}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4988                   \{\par
4989 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
4990   {\cf20 // This condition is always false so AlwaysTrue() never actually throws,}\par
4991   {\cf20 // but it makes the compiler think that it may throw.}\par
4992   {\cf19 if} (IsTrue({\cf17 false}))\par
4993     {\cf19 throw} ClassUniqueToAlwaysTrue();\par
4994 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
4995   {\cf19 return} {\cf17 true};\par
4996 \}\par
}
{
\ql
References IsTrue().}\par
{
\ql
Referenced by AlwaysFalse(), and SplitString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4d46f09c3bfe68700b7f728d2cc3782f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4d46f09c3bfe68700b7f728d2cc3782f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v AppendUserMessage\:testing::internal}
{\xe \v testing::internal\:AppendUserMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::AppendUserMessage (const {\b std::string} &  {\i gtest_msg}, const {\b Message} &  {\i user_msg})}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2002                                                        \{\par
2003   {\cf20 // Appends the user message if it's non-empty.}\par
2004   {\cf17 const} std::string user_msg_string = user_msg.GetString();\par
2005   {\cf19 if} (user_msg_string.empty()) \{\par
2006     {\cf19 return} gtest_msg;\par
2007   \}\par
2008 \par
2009   {\cf19 return} gtest_msg + {\cf22 "\\n"} + user_msg_string;\par
2010 \}\par
}
{
\ql
References std::string::empty(), and testing::Message::GetString().}\par
{
\ql
Referenced by testing::internal::AssertHelper::operator=().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af69e146a989e8d48def39a0cc59461c9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af69e146a989e8d48def39a0cc59461c9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ArrayAwareFind\:testing::internal}
{\xe \v testing::internal\:ArrayAwareFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iter , typename Element > Iter testing::internal::ArrayAwareFind (Iter  {\i begin}, Iter  {\i end}, const Element &  {\i elem})}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 983                                                                \{\par
984   {\cf19 for} (Iter it = begin; it != end; ++it) \{\par
985     {\cf19 if} (internal::ArrayEq(*it, elem))\par
986       {\cf19 return} it;\par
987   \}\par
988   {\cf19 return} end;\par
989 \}\par
}
{
\ql
References ArrayEq().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a94a857fe6ff32cf4fdc4769a4071f239_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > bool testing::internal::ArrayEq (const T &  {\i lhs}, const U &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 960 \{ {\cf19 return} lhs == rhs; \}\par
}
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > bool testing::internal::ArrayEq (const T *  {\i lhs}, size_t  {\i size}, const U *  {\i rhs})}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 972                                                       \{\par
973   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
974     {\cf19 if} (!internal::ArrayEq(lhs[i], rhs[i]))\par
975       {\cf19 return} {\cf17 false};\par
976   \}\par
977   {\cf19 return} {\cf17 true};\par
978 \}\par
}
{
\ql
Referenced by ArrayAwareFind(), ArrayEq(), and testing::internal::NativeArray< Element >::operator==().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af4bebf36baf0b0a5b26d051dde55fa47_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , size_t N> bool testing::internal::ArrayEq (const T(&)  {\i lhs}[N], const U(&)  {\i rhs}[N])}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 964                                                         \{\par
965   {\cf19 return} internal::ArrayEq(lhs, N, rhs);\par
966 \}\par
}
{
\ql
References ArrayEq().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5cb6f81ee827130024261121c742b26c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v BoolFromGTestEnv\:testing::internal}
{\xe \v testing::internal\:BoolFromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::BoolFromGTestEnv (const char *  {\i flag}, bool  {\i default_value})}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1191                                                             \{\par
1192 {\cf21 #if defined(GTEST_GET_BOOL_FROM_ENV_)}\par
1193   {\cf19 return} GTEST_GET_BOOL_FROM_ENV_(flag, default_value);\par
1194 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_BOOL_FROM_ENV_)}\par
1195   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
1196   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
1197   {\cf19 return} string_value == NULL ?\par
1198       default_value : strcmp(string_value, {\cf22 "0"}) != 0;\par
1199 \}\par
}
{
\ql
References std::string::c_str(), FlagToEnvVar(), and testing::internal::posix::GetEnv().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1055088bb9b867e1b7b8f096f519d7c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CaptureStderr\:testing::internal}
{\xe \v testing::internal\:CaptureStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::CaptureStderr ()}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CaptureStdout\:testing::internal}
{\xe \v testing::internal\:CaptureStdout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::CaptureStdout ()}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CheckedDowncastToActualType\:testing::internal}
{\xe \v testing::internal\:CheckedDowncastToActualType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Derived , class Base > Derived* testing::internal::CheckedDowncastToActualType (Base *  {\i base})}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1392                                                  \{\par
1393 {\cf21 #if GTEST_HAS_RTTI}\par
1394   GTEST_CHECK_({\cf17 typeid}(*base) == {\cf17 typeid}(Derived));\par
1395 {\cf21 #endif}\par
1396 \par
1397 {\cf21 #if GTEST_HAS_DOWNCAST_}\par
1398   return ::down_cast<Derived*>(base);\par
1399 {\cf21 #elif GTEST_HAS_RTTI}\par
1400   {\cf19 return} {\cf17 dynamic_cast<}Derived*{\cf17 >}(base);  {\cf20 // NOLINT}\par
1401 {\cf21 #else}\par
1402   {\cf19 return} {\cf17 static_cast<}Derived*{\cf17 >}(base);  {\cf20 // Poor man's downcast.}\par
1403 {\cf21 #endif}\par
1404 \}\par
}
{
\ql
References GTEST_CHECK_.}\par
}
{\xe \v ChopLowBits\:testing::internal}
{\xe \v testing::internal\:ChopLowBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt32} testing::internal::ChopLowBits ({\b UInt32} *  {\i bits}, int  {\i n})}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1747                                                \{\par
1748   {\cf17 const} UInt32 low_bits = *bits & (({\cf17 static_cast<}UInt32{\cf17 >}(1) << n) - 1);\par
1749   *bits >>= n;\par
1750   {\cf19 return} low_bits;\par
1751 \}\par
}
{
\ql
Referenced by CodePointToUtf8().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a2c54b453387aa8a18f2f3e09f10b5a7d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, {\b BiggestInt}  {\i lhs}, {\b BiggestInt}  {\i rhs})}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1440                                             \{\par
1441   {\cf19 if} (lhs == rhs) \{\par
1442     {\cf19 return} AssertionSuccess();\par
1443   \}\par
1444 \par
1445   {\cf19 return} EqFailure(lhs_expression,\par
1446                    rhs_expression,\par
1447                    FormatForComparisonFailureMessage(lhs, rhs),\par
1448                    FormatForComparisonFailureMessage(rhs, lhs),\par
1449                    {\cf17 false});\par
1450 \}\par
}
{
\ql
References testing::AssertionSuccess(), EqFailure(), and FormatForComparisonFailureMessage().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1edf90480571c0659a39d13e3777d9ce_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1390                                            \{\par
1391 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 {\cf20 /* signed/unsigned mismatch */})\par
1392   if (lhs == rhs) \{\par
1393     {\cf19 return} AssertionSuccess();\par
1394   \}\par
1395 GTEST_DISABLE_MSC_WARNINGS_POP_()\par
1396 \par
1397   return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\par
1398 \}\par
}
{
\ql
References testing::AssertionSuccess(), CmpHelperEQFailure(), GTEST_DISABLE_MSC_WARNINGS_POP_, and GTEST_DISABLE_MSC_WARNINGS_PUSH_.}\par
{
\ql
Referenced by testing::internal::EqHelper< lhs_is_null_literal >::Compare(), and testing::internal::EqHelper< true >::Compare().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4638c74d9b32e971f9b321af6fafc2f1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4638c74d9b32e971f9b321af6fafc2f1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperEQFailure\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperEQFailure (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1377                                                                  \{\par
1378   {\cf19 return} EqFailure(lhs_expression,\par
1379                    rhs_expression,\par
1380                    FormatForComparisonFailureMessage(lhs, rhs),\par
1381                    FormatForComparisonFailureMessage(rhs, lhs),\par
1382                    {\cf17 false});\par
1383 \}\par
}
{
\ql
References EqFailure(), and FormatForComparisonFailureMessage().}\par
{
\ql
Referenced by CmpHelperEQ().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1def8ec9393360a1b34a20528703e7f7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1def8ec9393360a1b34a20528703e7f7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperFloatingPointEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperFloatingPointEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b AssertionResult} testing::internal::CmpHelperFloatingPointEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, RawType  {\i lhs_value}, RawType  {\i rhs_value})}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1634                                                             \{\par
1635   {\cf17 const} FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\par
1636 \par
1637   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
1638     {\cf19 return} AssertionSuccess();\par
1639   \}\par
1640 \par
1641   ::std::stringstream lhs_ss;\par
1642   lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
1643          << lhs_value;\par
1644 \par
1645   ::std::stringstream rhs_ss;\par
1646   rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
1647          << rhs_value;\par
1648 \par
1649   {\cf19 return} EqFailure(lhs_expression,\par
1650                    rhs_expression,\par
1651                    StringStreamToString(&lhs_ss),\par
1652                    StringStreamToString(&rhs_ss),\par
1653                    {\cf17 false});\par
1654 \}\par
}
{
\ql
References testing::AssertionSuccess(), EqFailure(), std::setprecision(), and StringStreamToString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a98ce463e5dbe0c6120fa817e1f8f2944_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperOpFailure\:testing::internal}
{\xe \v testing::internal\:CmpHelperOpFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperOpFailure (const char *  {\i expr1}, const char *  {\i expr2}, const T1 &  {\i val1}, const T2 &  {\i val2}, const char *  {\i op})}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1488                                                    \{\par
1489   {\cf19 return} AssertionFailure()\par
1490          << {\cf22 "Expected: ("} << expr1 << {\cf22 ") "} << op << {\cf22 " ("} << expr2\par
1491          << {\cf22 "), actual: "} << FormatForComparisonFailureMessage(val1, val2)\par
1492          << {\cf22 " vs "} << FormatForComparisonFailureMessage(val2, val1);\par
1493 \}\par
}
{
\ql
References testing::AssertionFailure(), and FormatForComparisonFailureMessage().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a894ffccd936d78fd555f490020c27f0a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTRCASEEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRCASEEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTRCASEEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const char *  {\i lhs}, const char *  {\i rhs})}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1506                                                     \{\par
1507   {\cf19 if} (String::CaseInsensitiveCStringEquals(lhs, rhs)) \{\par
1508     {\cf19 return} AssertionSuccess();\par
1509   \}\par
1510 \par
1511   {\cf19 return} EqFailure(lhs_expression,\par
1512                    rhs_expression,\par
1513                    PrintToString(lhs),\par
1514                    PrintToString(rhs),\par
1515                    {\cf17 true});\par
1516 \}\par
}
{
\ql
References testing::AssertionSuccess(), testing::internal::String::CaseInsensitiveCStringEquals(), EqFailure(), and testing::PrintToString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a898b1e47a9d978e99318b224f69a54e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTRCASENE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRCASENE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTRCASENE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1536                                                    \{\par
1537   {\cf19 if} (!String::CaseInsensitiveCStringEquals(s1, s2)) \{\par
1538     {\cf19 return} AssertionSuccess();\par
1539   \} {\cf19 else} \{\par
1540     {\cf19 return} AssertionFailure()\par
1541         << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
1542         << s2_expression << {\cf22 ") (ignoring case), actual: \\""}\par
1543         << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
1544   \}\par
1545 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::AssertionSuccess(), and testing::internal::String::CaseInsensitiveCStringEquals().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5f74b933606b0a742cd5a8ad2d7087e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTREQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTREQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const char *  {\i lhs}, const char *  {\i rhs})}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1490                                                 \{\par
1491   {\cf19 if} (String::CStringEquals(lhs, rhs)) \{\par
1492     {\cf19 return} AssertionSuccess();\par
1493   \}\par
1494 \par
1495   {\cf19 return} EqFailure(lhs_expression,\par
1496                    rhs_expression,\par
1497                    PrintToString(lhs),\par
1498                    PrintToString(rhs),\par
1499                    {\cf17 false});\par
1500 \}\par
}
{
\ql
References testing::AssertionSuccess(), testing::internal::String::CStringEquals(), EqFailure(), and testing::PrintToString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a2863c85877728b2c223cf6ade4a530c1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTREQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTREQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const wchar_t *  {\i lhs}, const wchar_t *  {\i rhs})}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1872                                                    \{\par
1873   {\cf19 if} (String::WideCStringEquals(lhs, rhs)) \{\par
1874     {\cf19 return} AssertionSuccess();\par
1875   \}\par
1876 \par
1877   {\cf19 return} EqFailure(lhs_expression,\par
1878                    rhs_expression,\par
1879                    PrintToString(lhs),\par
1880                    PrintToString(rhs),\par
1881                    {\cf17 false});\par
1882 \}\par
}
{
\ql
References testing::AssertionSuccess(), EqFailure(), testing::PrintToString(), and testing::internal::String::WideCStringEquals().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a96fddadf115749a0743bc254550266e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTRNE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTRNE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1522                                                \{\par
1523   {\cf19 if} (!String::CStringEquals(s1, s2)) \{\par
1524     {\cf19 return} AssertionSuccess();\par
1525   \} {\cf19 else} \{\par
1526     {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
1527                               << s2_expression << {\cf22 "), actual: \\""}\par
1528                               << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
1529   \}\par
1530 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::AssertionSuccess(), and testing::internal::String::CStringEquals().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6b485231a046ff760844a0321c04870b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CmpHelperSTRNE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::CmpHelperSTRNE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const wchar_t *  {\i s1}, const wchar_t *  {\i s2})}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1888                                                   \{\par
1889   {\cf19 if} (!String::WideCStringEquals(s1, s2)) \{\par
1890     {\cf19 return} AssertionSuccess();\par
1891   \}\par
1892 \par
1893   {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
1894                             << s2_expression << {\cf22 "), actual: "}\par
1895                             << PrintToString(s1)\par
1896                             << {\cf22 " vs "} << PrintToString(s2);\par
1897 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::AssertionSuccess(), testing::PrintToString(), and testing::internal::String::WideCStringEquals().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6e700804399b6694d8d6157e3a141b17_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CodePointToUtf8\:testing::internal}
{\xe \v testing::internal\:CodePointToUtf8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::CodePointToUtf8 ({\b UInt32}  {\i code_point})}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1759                                              \{\par
1760   {\cf19 if} (code_point > kMaxCodePoint4) \{\par
1761     {\cf19 return} {\cf22 "(Invalid Unicode 0x"} + String::FormatHexInt(code_point) + {\cf22 ")"};\par
1762   \}\par
1763 \par
1764   {\cf18 char} str[5];  {\cf20 // Big enough for the largest valid code point.}\par
1765   {\cf19 if} (code_point <= kMaxCodePoint1) \{\par
1766     str[1] = {\cf23 '\\0'};\par
1767     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(code_point);                          {\cf20 // 0xxxxxxx}\par
1768   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint2) \{\par
1769     str[2] = {\cf23 '\\0'};\par
1770     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1771     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xC0 | code_point);                   {\cf20 // 110xxxxx}\par
1772   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint3) \{\par
1773     str[3] = {\cf23 '\\0'};\par
1774     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1775     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1776     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xE0 | code_point);                   {\cf20 // 1110xxxx}\par
1777   \} {\cf19 else} \{  {\cf20 // code_point <= kMaxCodePoint4}\par
1778     str[4] = {\cf23 '\\0'};\par
1779     str[3] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1780     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1781     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
1782     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF0 | code_point);                   {\cf20 // 11110xxx}\par
1783   \}\par
1784   {\cf19 return} str;\par
1785 \}\par
}
{
\ql
References ChopLowBits(), testing::internal::String::FormatHexInt(), kMaxCodePoint1, kMaxCodePoint2, kMaxCodePoint3, and kMaxCodePoint4.}\par
{
\ql
Referenced by WideStringToUtf8().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0c0f9558efb9abb965851c4738cdc725_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0c0f9558efb9abb965851c4738cdc725_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ColoredPrintf\:testing::internal}
{\xe \v testing::internal\:ColoredPrintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ColoredPrintf ({\b GTestColor}  {\i color}, const char *  {\i fmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2956                                                            \{\par
2957   va_list args;\par
2958   va_start(args, fmt);\par
2959 \par
2960 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || \\}\par
2961 {\cf21     GTEST_OS_IOS || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
2962   {\cf17 const} {\cf18 bool} use_color = AlwaysFalse();\par
2963 {\cf21 #else}\par
2964   {\cf17 static} {\cf17 const} {\cf18 bool} in_color_mode =\par
2965       ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);\par
2966   {\cf17 const} {\cf18 bool} use_color = in_color_mode && (color != COLOR_DEFAULT);\par
2967 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS}\par
2968   {\cf20 // The '!= 0' comparison is necessary to satisfy MSVC 7.1.}\par
2969 \par
2970   {\cf19 if} (!use_color) \{\par
2971     vprintf(fmt, args);\par
2972     va_end(args);\par
2973     {\cf19 return};\par
2974   \}\par
2975 \par
2976 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \\}\par
2977 {\cf21     !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
2978   {\cf17 const} HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);\par
2979 \par
2980   {\cf20 // Gets the current text color.}\par
2981   CONSOLE_SCREEN_BUFFER_INFO buffer_info;\par
2982   GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);\par
2983   {\cf17 const} WORD old_color_attrs = buffer_info.wAttributes;\par
2984 \par
2985   {\cf20 // We need to flush the stream buffers into the console before each}\par
2986   {\cf20 // SetConsoleTextAttribute call lest it affect the text that is already}\par
2987   {\cf20 // printed but has not yet reached the console.}\par
2988   fflush(stdout);\par
2989   SetConsoleTextAttribute(stdout_handle,\par
2990                           GetColorAttribute(color) | FOREGROUND_INTENSITY);\par
2991   vprintf(fmt, args);\par
2992 \par
2993   fflush(stdout);\par
2994   {\cf20 // Restores the text color.}\par
2995   SetConsoleTextAttribute(stdout_handle, old_color_attrs);\par
2996 {\cf21 #else}\par
2997   printf({\cf22 "\\033[0;3%sm"}, GetAnsiColorCode(color));\par
2998   vprintf(fmt, args);\par
2999   printf({\cf22 "\\033[m"});  {\cf20 // Resets the terminal to default.}\par
3000 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
3001   va_end(args);\par
3002 \}\par
}
{
\ql
References AlwaysFalse(), COLOR_DEFAULT, testing::internal::posix::FileNo(), GetAnsiColorCode(), testing::internal::posix::IsATTY(), and ShouldUseColor().}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(), testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(), testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd(), testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart(), testing::internal::PrettyUnitTestResultPrinter::OnTestEnd(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(), testing::internal::PrettyUnitTestResultPrinter::OnTestStart(), PrintColorEncoded(), testing::internal::PrettyUnitTestResultPrinter::PrintFailedTests(), ShouldShard(), and WriteToShardStatusFileIfNeeded().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_adef3055706176001364e54eb73a87e31_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_adef3055706176001364e54eb73a87e31_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > void testing::internal::CopyArray (const T &  {\i from}, U *  {\i to})}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1000 \{ *to = from; \}\par
}
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > void testing::internal::CopyArray (const T *  {\i from}, size_t  {\i size}, U *  {\i to})}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1012                                                   \{\par
1013   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
1014     internal::CopyArray(from[i], to + i);\par
1015   \}\par
1016 \}\par
}
{
\ql
Referenced by CopyArray(), and testing::internal::NativeArray< Element >::InitCopy().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_afb1b9728aaaf6d9fe6246a19cfe3f7f5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , size_t N> void testing::internal::CopyArray (const T(&)  {\i from}[N], U(*)  {\i to}[N])}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1004                                                     \{\par
1005   internal::CopyArray(from, N, *to);\par
1006 \}\par
}
{
\ql
References CopyArray().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1e7ae855686720615dcd5754c8181c62_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CountIf\:testing::internal}
{\xe \v testing::internal\:CountIf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Container , typename Predicate > int testing::internal::CountIf (const Container &  {\i c}, Predicate  {\i predicate})}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 283                                                             \{\par
284   {\cf20 // Implemented as an explicit loop since std::count_if() in libCstd on}\par
285   {\cf20 // Solaris has a non-standard signature.}\par
286   {\cf18 int} count = 0;\par
287   {\cf19 for} ({\cf17 typename} Container::const_iterator it = c.begin(); it != c.end(); ++it) \{\par
288     {\cf19 if} (predicate(*it))\par
289       ++count;\par
290   \}\par
291   {\cf19 return} count;\par
292 \}\par
}
{
\ql
Referenced by testing::TestCase::disabled_test_count(), testing::internal::UnitTestImpl::failed_test_case_count(), testing::TestCase::failed_test_count(), testing::TestResult::HasFatalFailure(), testing::TestResult::HasNonfatalFailure(), testing::TestCase::reportable_disabled_test_count(), testing::TestCase::reportable_test_count(), testing::internal::UnitTestImpl::successful_test_case_count(), testing::TestCase::successful_test_count(), testing::internal::UnitTestImpl::test_case_to_run_count(), and testing::TestCase::test_to_run_count().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1e77a774d910346eff11a86d8df783a5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v CreateCodePointFromUtf16SurrogatePair\:testing::internal}
{\xe \v testing::internal\:CreateCodePointFromUtf16SurrogatePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt32} testing::internal::CreateCodePointFromUtf16SurrogatePair (wchar_t  {\i first}, wchar_t  {\i second})}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1801                                                                     \{\par
1802   {\cf17 const} UInt32 mask = (1 << 10) - 1;\par
1803   {\cf19 return} ({\cf17 sizeof}({\cf18 wchar_t}) == 2) ?\par
1804       (((first & mask) << 10) | (second & mask)) + 0x10000 :\par
1805       {\cf20 // This function should not be called when the condition is}\par
1806       {\cf20 // false, but we provide a sensible default in case it is.}\par
1807       {\cf17 static_cast<}UInt32{\cf17 >}(first);\par
1808 \}\par
}
{
\ql
Referenced by WideStringToUtf8().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac8ef1bb10cd9e69de939789b759e6bc9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > void testing::internal::DefaultPrintTo ({\b IsContainer} , {\b false_type} , const C &  {\i container}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 372                                                         \{\par
373   {\cf17 const} {\cf18 size_t} kMaxCount = 32;  {\cf20 // The maximum number of elements to print.}\par
374   *os << {\cf23 '\{'};\par
375   {\cf18 size_t} count = 0;\par
376   {\cf19 for} ({\cf17 typename} C::const_iterator it = container.begin();\par
377        it != container.end(); ++it, ++count) \{\par
378     {\cf19 if} (count > 0) \{\par
379       *os << {\cf23 ','};\par
380       {\cf19 if} (count == kMaxCount) \{  {\cf20 // Enough has been printed.}\par
381         *os << {\cf22 " ..."};\par
382         {\cf19 break};\par
383       \}\par
384     \}\par
385     *os << {\cf23 ' '};\par
386     {\cf20 // We cannot call PrintTo(*it, os) here as PrintTo() doesn't}\par
387     {\cf20 // handle *it being a native array.}\par
388     internal::UniversalPrint(*it, os);\par
389   \}\par
390 \par
391   {\cf19 if} (count > 0) \{\par
392     *os << {\cf23 ' '};\par
393   \}\par
394   *os << {\cf23 '\}'};\par
395 \}\par
}
{
\ql
References UniversalPrint().}\par
{
\ql
Referenced by PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac7dfe02c4c1cbfe89c23a93d873079c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac7dfe02c4c1cbfe89c23a93d873079c5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::DefaultPrintTo ({\b IsNotContainer} , {\b false_type} , const T &  {\i value}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 438                                                     \{\par
439   ::testing_internal::DefaultPrintNonContainerTo(value, os);\par
440 \}\par
}
{
\ql
References testing_internal::DefaultPrintNonContainerTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a78e4937ba564f01dac2ff25f3eece0ec_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::DefaultPrintTo ({\b IsNotContainer} , {\b true_type} , T *  {\i p}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 406                                           \{\par
407   {\cf19 if} (p == NULL) \{\par
408     *os << {\cf22 "NULL"};\par
409   \} {\cf19 else} \{\par
410     {\cf20 // C++ doesn't allow casting from a function pointer to any object}\par
411     {\cf20 // pointer.}\par
412     {\cf20 //}\par
413     {\cf20 // IsTrue() silences warnings: "Condition is always true",}\par
414     {\cf20 // "unreachable code".}\par
415     {\cf19 if} (IsTrue(ImplicitlyConvertible<T*, const void*>::value)) \{\par
416       {\cf20 // T is not a function type.  We just call << to print p,}\par
417       {\cf20 // relying on ADL to pick up user-defined << for their pointer}\par
418       {\cf20 // types, if any.}\par
419       *os << p;\par
420     \} {\cf19 else} \{\par
421       {\cf20 // T is a function type, so '*os << p' doesn't do what we want}\par
422       {\cf20 // (it just prints p as bool).  We want to print p as a const}\par
423       {\cf20 // void*.  However, we cannot cast it to const void* directly,}\par
424       {\cf20 // even using reinterpret_cast, as earlier versions of gcc}\par
425       {\cf20 // (e.g. 3.4.5) cannot compile the cast when p is a function}\par
426       {\cf20 // pointer.  Casting to UInt64 first solves the problem.}\par
427       *os << reinterpret_cast<const void*>(\par
428           {\cf17 reinterpret_cast<}internal::UInt64{\cf17 >}(p));\par
429     \}\par
430   \}\par
431 \}\par
}
{
\ql
References IsTrue().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_affa1f94e3ba8db8b964553c2871bf339_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Delete\:testing::internal}
{\xe \v testing::internal\:Delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void testing::internal::Delete (T *  {\i x}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 340                          \{\par
341   {\cf17 delete} x;\par
342 \}\par
}
}
{\xe \v DiffStrings\:testing::internal}
{\xe \v testing::internal\:DiffStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::DiffStrings (const {\b std::string} &  {\i left}, const {\b std::string} &  {\i right}, size_t *  {\i total_line_count})}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DoubleNearPredFormat\:testing::internal}
{\xe \v testing::internal\:DoubleNearPredFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::DoubleNearPredFormat (const char *  {\i expr1}, const char *  {\i expr2}, const char *  {\i abs_error_expr}, double  {\i val1}, double  {\i val2}, double  {\i abs_error})}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1367                                                        \{\par
1368   {\cf17 const} {\cf18 double} diff = fabs(val1 - val2);\par
1369   {\cf19 if} (diff <= abs_error) {\cf19 return} AssertionSuccess();\par
1370 \par
1371   {\cf20 // TODO(wan): do not print the value of an expression if it's}\par
1372   {\cf20 // already a literal.}\par
1373   {\cf19 return} AssertionFailure()\par
1374       << {\cf22 "The difference between "} << expr1 << {\cf22 " and "} << expr2\par
1375       << {\cf22 " is "} << diff << {\cf22 ", which exceeds "} << abs_error_expr << {\cf22 ", where\\n"}\par
1376       << expr1 << {\cf22 " evaluates to "} << val1 << {\cf22 ",\\n"}\par
1377       << expr2 << {\cf22 " evaluates to "} << val2 << {\cf22 ", and\\n"}\par
1378       << abs_error_expr << {\cf22 " evaluates to "} << abs_error << {\cf22 "."};\par
1379 \}\par
}
{
\ql
References testing::AssertionFailure(), and testing::AssertionSuccess().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aea60207c4cedc8946a70ada62e38da8f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v DownCast_\:testing::internal}
{\xe \v testing::internal\:DownCast_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename To , typename From > To testing::internal::DownCast_ (From *  {\i f})}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1367                              \{  {\cf20 // so we only accept pointers}\par
1368   {\cf20 // Ensures that To is a sub-type of From *.  This test is here only}\par
1369   {\cf20 // for compile-time type checking, and has no overhead in an}\par
1370   {\cf20 // optimized build at run-time, as it will be optimized away}\par
1371   {\cf20 // completely.}\par
1372   GTEST_INTENTIONAL_CONST_COND_PUSH_()\par
1373   if (false) \{\par
1374   GTEST_INTENTIONAL_CONST_COND_POP_()\par
1375     const To to = NULL;\par
1376     ::testing::internal::ImplicitCast_<From*>(to);\par
1377   \}\par
1378 \par
1379 {\cf21 #if GTEST_HAS_RTTI}\par
1380   {\cf20 // RTTI: debug mode only!}\par
1381   GTEST_CHECK_(f == NULL || {\cf17 dynamic_cast<}To{\cf17 >}(f) != NULL);\par
1382 {\cf21 #endif}\par
1383   {\cf19 return} {\cf17 static_cast<}To{\cf17 >}(f);\par
1384 \}\par
}
{
\ql
References GTEST_CHECK_, GTEST_INTENTIONAL_CONST_COND_POP_, and GTEST_INTENTIONAL_CONST_COND_PUSH_.}\par
}
{\xe \v EqFailure\:testing::internal}
{\xe \v testing::internal\:EqFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b AssertionResult} testing::internal::EqFailure (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const {\b std::string} &  {\i lhs_value}, const {\b std::string} &  {\i rhs_value}, bool  {\i ignoring_case})}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1316                                               \{\par
1317   Message msg;\par
1318   msg << {\cf22 "      Expected: "} << lhs_expression;\par
1319   {\cf19 if} (lhs_value != lhs_expression) \{\par
1320     msg << {\cf22 "\\n      Which is: "} << lhs_value;\par
1321   \}\par
1322   msg << {\cf22 "\\nTo be equal to: "} << rhs_expression;\par
1323   {\cf19 if} (rhs_value != rhs_expression) \{\par
1324     msg << {\cf22 "\\n      Which is: "} << rhs_value;\par
1325   \}\par
1326 \par
1327   {\cf19 if} (ignoring_case) \{\par
1328     msg << {\cf22 "\\nIgnoring case"};\par
1329   \}\par
1330 \par
1331   {\cf19 if} (!lhs_value.empty() && !rhs_value.empty()) \{\par
1332     {\cf17 const} std::vector<std::string> lhs_lines =\par
1333         SplitEscapedString(lhs_value);\par
1334     {\cf17 const} std::vector<std::string> rhs_lines =\par
1335         SplitEscapedString(rhs_value);\par
1336     {\cf19 if} (lhs_lines.size() > 1 || rhs_lines.size() > 1) \{\par
1337       msg << {\cf22 "\\nWith diff:\\n"}\par
1338           << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\par
1339     \}\par
1340   \}\par
1341 \par
1342   {\cf19 return} AssertionFailure() << msg;\par
1343 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::internal::edit_distance::CreateUnifiedDiff(), std::string::empty(), std::vector< T >::size(), and testing::internal::anonymous_namespace\{gtest.cc\}::SplitEscapedString().}\par
{
\ql
Referenced by CmpHelperEQ(), CmpHelperEQFailure(), CmpHelperFloatingPointEQ(), CmpHelperSTRCASEEQ(), and CmpHelperSTREQ().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a290e3967783ec2de56981c8b1cec37de_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a290e3967783ec2de56981c8b1cec37de_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FlagToEnvVar\:testing::internal}
{\xe \v testing::internal\:FlagToEnvVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::internal::FlagToEnvVar (const char *  {\i flag}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1134                                                 \{\par
1135   {\cf17 const} std::string full_flag =\par
1136       (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();\par
1137 \par
1138   Message env_var;\par
1139   {\cf19 for} ({\cf18 size_t} i = 0; i != full_flag.length(); i++) \{\par
1140     env_var << ToUpper(full_flag.c_str()[i]);\par
1141   \}\par
1142 \par
1143   {\cf19 return} env_var.GetString();\par
1144 \}\par
}
{
\ql
References std::string::c_str(), testing::Message::GetString(), GTEST_FLAG_PREFIX_, std::string::length(), and ToUpper().}\par
{
\ql
Referenced by BoolFromGTestEnv(), Int32FromGTestEnv(), and StringFromGTestEnv().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7540386ecf74d7ab7e2fa6089db94682_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7540386ecf74d7ab7e2fa6089db94682_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FloatingPointLE\:testing::internal}
{\xe \v testing::internal\:FloatingPointLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b AssertionResult} testing::internal::FloatingPointLE (const char *  {\i expr1}, const char *  {\i expr2}, RawType  {\i val1}, RawType  {\i val2})}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1387                                               \{\par
1388   {\cf20 // Returns success if val1 is less than val2,}\par
1389   {\cf19 if} (val1 < val2) \{\par
1390     {\cf19 return} AssertionSuccess();\par
1391   \}\par
1392 \par
1393   {\cf20 // or if val1 is almost equal to val2.}\par
1394   {\cf17 const} FloatingPoint<RawType> lhs(val1), rhs(val2);\par
1395   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
1396     {\cf19 return} AssertionSuccess();\par
1397   \}\par
1398 \par
1399   {\cf20 // Note that the above two checks will both fail if either val1 or}\par
1400   {\cf20 // val2 is NaN, as the IEEE floating-point standard requires that}\par
1401   {\cf20 // any predicate involving a NaN must return false.}\par
1402 \par
1403   ::std::stringstream val1_ss;\par
1404   val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
1405           << val1;\par
1406 \par
1407   ::std::stringstream val2_ss;\par
1408   val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
1409           << val2;\par
1410 \par
1411   {\cf19 return} AssertionFailure()\par
1412       << {\cf22 "Expected: ("} << expr1 << {\cf22 ") <= ("} << expr2 << {\cf22 ")\\n"}\par
1413       << {\cf22 "  Actual: "} << StringStreamToString(&val1_ss) << {\cf22 " vs "}\par
1414       << StringStreamToString(&val2_ss);\par
1415 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::AssertionSuccess(), std::setprecision(), and StringStreamToString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a17b52b6b1f81f6dcad5cc4d12e5173a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FlushInfoLog\:testing::internal}
{\xe \v testing::internal\:FlushInfoLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::FlushInfoLog ()}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1276 \{ fflush(NULL); \}\par
}
}
{\xe \v ForEach\:testing::internal}
{\xe \v testing::internal\:ForEach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Container , typename Functor > void testing::internal::ForEach (const Container &  {\i c}, Functor  {\i functor})}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 296                                                   \{\par
297   std::for_each(c.begin(), c.end(), functor);\par
298 \}\par
}
{
\ql
References std::for_each().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::ClearNonAdHocTestResult(), testing::TestCase::ClearResult(), testing::internal::UnitTestImpl::RunAllTests(), testing::TestCase::~TestCase(), testing::internal::TestEventRepeater::~TestEventRepeater(), and testing::internal::UnitTestImpl::~UnitTestImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a52f5504ed65d116201ccb8f99a44fd7e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a52f5504ed65d116201ccb8f99a44fd7e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatCompilerIndependentFileLocation\:testing::internal}
{\xe \v testing::internal\:FormatCompilerIndependentFileLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GTEST_API_::std::string testing::internal::FormatCompilerIndependentFileLocation (const char *  {\i file}, int  {\i line})}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 899                                 \{\par
900   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
901 \par
902   {\cf19 if} (line < 0)\par
903     {\cf19 return} file_name;\par
904   {\cf19 else}\par
905     {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line);\par
906 \}\par
}
{
\ql
References kUnknownFile, and StreamableToString().}\par
{
\ql
Referenced by testing::internal::XmlUnitTestResultPrinter::OutputXmlTestInfo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1ee4cde97868c53e442d3182496a9f3c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1ee4cde97868c53e442d3182496a9f3c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatEpochTimeInMillisAsIso8601\:testing::internal}
{\xe \v testing::internal\:FormatEpochTimeInMillisAsIso8601}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::FormatEpochTimeInMillisAsIso8601 ({\b TimeInMillis}  {\i ms})}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3574                                                             \{\par
3575   {\cf17 struct }tm time_struct;\par
3576   {\cf19 if} (!PortableLocaltime({\cf17 static_cast<}time_t{\cf17 >}(ms / 1000), &time_struct))\par
3577     {\cf19 return} {\cf22 ""};\par
3578   {\cf20 // YYYY-MM-DDThh:mm:ss}\par
3579   {\cf19 return} StreamableToString(time_struct.tm_year + 1900) + {\cf22 "-"} +\par
3580       String::FormatIntWidth2(time_struct.tm_mon + 1) + {\cf22 "-"} +\par
3581       String::FormatIntWidth2(time_struct.tm_mday) + {\cf22 "T"} +\par
3582       String::FormatIntWidth2(time_struct.tm_hour) + {\cf22 ":"} +\par
3583       String::FormatIntWidth2(time_struct.tm_min) + {\cf22 ":"} +\par
3584       String::FormatIntWidth2(time_struct.tm_sec);\par
3585 \}\par
}
{
\ql
References testing::internal::String::FormatIntWidth2(), PortableLocaltime(), and StreamableToString().}\par
{
\ql
Referenced by testing::internal::XmlUnitTestResultPrinter::PrintXmlUnitTest().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5ef227c4a610e7ff638b12dfb25b068e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5ef227c4a610e7ff638b12dfb25b068e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatFileLocation\:testing::internal}
{\xe \v testing::internal\:FormatFileLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GTEST_API_::std::string testing::internal::FormatFileLocation (const char *  {\i file}, int  {\i line})}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 880                                                                     \{\par
881   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
882 \par
883   {\cf19 if} (line < 0) \{\par
884     {\cf19 return} file_name + {\cf22 ":"};\par
885   \}\par
886 {\cf21 #ifdef _MSC_VER}\par
887   {\cf19 return} file_name + {\cf22 "("} + StreamableToString(line) + {\cf22 "):"};\par
888 {\cf21 #else}\par
889   {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line) + {\cf22 ":"};\par
890 {\cf21 #endif  }{\cf20 // _MSC_VER}\par
891 \}\par
}
{
\ql
References kUnknownFile, and StreamableToString().}\par
{
\ql
Referenced by testing::UnitTest::AddTestPartResult(), testing::internal::GTestLog::GTestLog(), and PrintTestPartResultToString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a31b7c3abed4a7c395f42c61e993989f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a31b7c3abed4a7c395f42c61e993989f4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatForComparisonFailureMessage\:testing::internal}
{\xe \v testing::internal\:FormatForComparisonFailureMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b std::string} testing::internal::FormatForComparisonFailureMessage (const T1 &  {\i value}, const T2 & )}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 350                                   \{\par
351   {\cf19 return} FormatForComparison<T1, T2>::Format(value);\par
352 \}\par
}
{
\ql
References testing::internal::FormatForComparison< ToPrint, OtherOperand >::Format().}\par
{
\ql
Referenced by CmpHelperEQ(), CmpHelperEQFailure(), and CmpHelperOpFailure().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a91ab078f10adc669f09b7f604975c518_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a91ab078f10adc669f09b7f604975c518_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v FormatTimeInMillisAsSeconds\:testing::internal}
{\xe \v testing::internal\:FormatTimeInMillisAsSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::FormatTimeInMillisAsSeconds ({\b TimeInMillis}  {\i ms})}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3550                                                        \{\par
3551   ::std::stringstream ss;\par
3552   ss << (static_cast<double>(ms) * 1e-3);\par
3553   {\cf19 return} ss.str();\par
3554 \}\par
}
{
\ql
References std::stringstream::str().}\par
{
\ql
Referenced by testing::internal::XmlUnitTestResultPrinter::OutputXmlTestInfo(), testing::internal::XmlUnitTestResultPrinter::PrintXmlTestCase(), and testing::internal::XmlUnitTestResultPrinter::PrintXmlUnitTest().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a904485f27a54be8a5a92856e2d838797_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a904485f27a54be8a5a92856e2d838797_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetAnsiColorCode\:testing::internal}
{\xe \v testing::internal\:GetAnsiColorCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* testing::internal::GetAnsiColorCode ({\b GTestColor}  {\i color})}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2904                                                \{\par
2905   {\cf19 switch} (color) \{\par
2906     {\cf19 case} COLOR_RED:     {\cf19 return} {\cf22 "1"};\par
2907     {\cf19 case} COLOR_GREEN:   {\cf19 return} {\cf22 "2"};\par
2908     {\cf19 case} COLOR_YELLOW:  {\cf19 return} {\cf22 "3"};\par
2909     {\cf19 default}:            {\cf19 return} NULL;\par
2910   \};\par
2911 \}\par
}
{
\ql
References COLOR_GREEN, COLOR_RED, and COLOR_YELLOW.}\par
{
\ql
Referenced by ColoredPrintf().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0aefb9deb60e90f19c236559837303d8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetArgvs\:testing::internal}
{\xe \v testing::internal\:GetArgvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} const ::{\b std::vector}< {\b testing::internal::string} > & testing::internal::GetArgvs ()}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 389                                                    \{\par
390 {\cf21 #if defined(GTEST_CUSTOM_GET_ARGVS_)}\par
391   {\cf19 return} GTEST_CUSTOM_GET_ARGVS_();\par
392 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
393   {\cf19 return} g_argvs;\par
394 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
395 \}\par
}
{
\ql
References g_argvs.}\par
{
\ql
Referenced by GetCurrentExecutableName(), and GTestIsInitialized().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4d364e5e40f433fff1604355617ea1a6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetBoolAssertionFailureMessage\:testing::internal}
{\xe \v testing::internal\:GetBoolAssertionFailureMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::GetBoolAssertionFailureMessage (const {\b AssertionResult} &  {\i assertion_result}, const char *  {\i expression_text}, const char *  {\i actual_predicate_value}, const char *  {\i expected_predicate_value})}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1350                                           \{\par
1351   {\cf17 const} {\cf18 char}* actual_message = assertion_result.message();\par
1352   Message msg;\par
1353   msg << {\cf22 "Value of: "} << expression_text\par
1354       << {\cf22 "\\n  Actual: "} << actual_predicate_value;\par
1355   {\cf19 if} (actual_message[0] != {\cf23 '\\0'})\par
1356     msg << {\cf22 " ("} << actual_message << {\cf22 ")"};\par
1357   msg << {\cf22 "\\nExpected: "} << expected_predicate_value;\par
1358   {\cf19 return} msg.GetString();\par
1359 \}\par
}
{
\ql
References testing::Message::GetString(), and testing::AssertionResult::message().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aed8d3ad4341f8f2de53440e39c995632_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetCapturedStderr\:testing::internal}
{\xe \v testing::internal\:GetCapturedStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::GetCapturedStderr ()}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GetCapturedStdout\:testing::internal}
{\xe \v testing::internal\:GetCapturedStdout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::GetCapturedStdout ()}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GetCurrentExecutableName\:testing::internal}
{\xe \v testing::internal\:GetCurrentExecutableName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::GetCurrentExecutableName ()}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 399                                     \{\par
400   FilePath result;\par
401 \par
402 {\cf21 #if GTEST_OS_WINDOWS}\par
403   result.Set(FilePath(GetArgvs()[0]).RemoveExtension({\cf22 "exe"}));\par
404 {\cf21 #else}\par
405   result.Set(FilePath(GetArgvs()[0]));\par
406 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
407 \par
408   {\cf19 return} result.RemoveDirectoryName();\par
409 \}\par
}
{
\ql
References GetArgvs(), testing::internal::FilePath::RemoveDirectoryName(), and testing::internal::FilePath::Set().}\par
{
\ql
Referenced by testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7a2bbf069f75bc99873976ad6fc356ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7a2bbf069f75bc99873976ad6fc356ad_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetCurrentOsStackTraceExceptTop\:testing::internal}
{\xe \v testing::internal\:GetCurrentOsStackTraceExceptTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::GetCurrentOsStackTraceExceptTop ({\b UnitTest} * , int  {\i skip_count})}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4974                                                             \{\par
4975   {\cf20 // We pass skip_count + 1 to skip this wrapper function in addition}\par
4976   {\cf20 // to what the user really wants to skip.}\par
4977   {\cf19 return} GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);\par
4978 \}\par
}
{
\ql
References testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop(), and GetUnitTestImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a9a8b7b80602acebfbe4149e57ba7d3eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetElementOr\:testing::internal}
{\xe \v testing::internal\:GetElementOr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > E testing::internal::GetElementOr (const {\b std::vector}< E > &  {\i v}, int  {\i i}, E  {\i default_value})}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 303                                                                      \{\par
304   {\cf19 return} (i < 0 || i >= {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v.size())) ? default_value : v[i];\par
305 \}\par
}
{
\ql
References std::vector< T >::size().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::GetMutableTestCase(), testing::TestCase::GetMutableTestInfo(), testing::internal::UnitTestImpl::GetTestCase(), and testing::TestCase::GetTestInfo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a71fdd20a0686bea3dc0cdcd95e0bca1c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a71fdd20a0686bea3dc0cdcd95e0bca1c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetFileSize\:testing::internal}
{\xe \v testing::internal\:GetFileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} size_t testing::internal::GetFileSize (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1076                                \{\par
1077   fseek(file, 0, SEEK_END);\par
1078   {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(ftell(file));\par
1079 \}\par
}
{
\ql
Referenced by ReadEntireFile().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a40bcfd87e26aae36e0cc51e5db64fd89_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetNextRandomSeed\:testing::internal}
{\xe \v testing::internal\:GetNextRandomSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::GetNextRandomSeed (int  {\i seed})}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 152                                        \{\par
153   GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)\par
154       << {\cf22 "Invalid random seed "} << seed << {\cf22 " - must be in [1, "}\par
155       << kMaxRandomSeed << {\cf22 "]."};\par
156   {\cf17 const} {\cf18 int} next_seed = seed + 1;\par
157   {\cf19 return} (next_seed > kMaxRandomSeed) ? 1 : next_seed;\par
158 \}\par
}
{
\ql
References GTEST_CHECK_, and kMaxRandomSeed.}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6e07a655cb987d131cd8fbeba9a7f1eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetRandomSeedFromFlag\:testing::internal}
{\xe \v testing::internal\:GetRandomSeedFromFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::GetRandomSeedFromFlag ({\b Int32}  {\i random_seed_flag})}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 136                                                          \{\par
137   {\cf17 const} {\cf18 unsigned} {\cf18 int} raw_seed = (random_seed_flag == 0) ?\par
138       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(GetTimeInMillis()) :\par
139       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(random_seed_flag);\par
140 \par
141   {\cf20 // Normalizes the actual seed to range [1, kMaxRandomSeed] such that}\par
142   {\cf20 // it's easy to type.}\par
143   {\cf17 const} {\cf18 int} normalized_seed =\par
144       {\cf17 static_cast<}{\cf18 int}{\cf17 >}((raw_seed - 1U) %\par
145                        {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(kMaxRandomSeed)) + 1;\par
146   {\cf19 return} normalized_seed;\par
147 \}\par
}
{
\ql
References GetTimeInMillis(), and kMaxRandomSeed.}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae74fedbdaebaac8d1202192266243b9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae74fedbdaebaac8d1202192266243b9e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetTestTypeId\:testing::internal}
{\xe \v testing::internal\:GetTestTypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b TypeId} testing::internal::GetTestTypeId ()}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 620                        \{\par
621   {\cf19 return} GetTypeId<Test>();\par
622 \}\par
}
{
\ql
Referenced by testing::Test::HasSameFixtureClass().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1e85cf16bb95b60f879d48ba1fbfc1c9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetThreadCount\:testing::internal}
{\xe \v testing::internal\:GetThreadCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} size_t testing::internal::GetThreadCount ()}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 169                         \{\par
170   {\cf20 // There's no portable way to detect the number of threads, so we just}\par
171   {\cf20 // return 0 to indicate that we cannot detect it.}\par
172   {\cf19 return} 0;\par
173 \}\par
}
}
{\xe \v GetTimeInMillis\:testing::internal}
{\xe \v testing::internal\:GetTimeInMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::internal::GetTimeInMillis ()}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 806                                \{\par
807 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)}\par
808   {\cf20 // Difference between 1970-01-01 and 1601-01-01 in milliseconds.}\par
809   {\cf20 // http://analogous.blogspot.com/2005/04/epoch.html}\par
810   {\cf17 const} TimeInMillis kJavaEpochToWinFileTimeDelta =\par
811     {\cf17 static_cast<}TimeInMillis{\cf17 >}(116444736UL) * 100000UL;\par
812   {\cf17 const} DWORD kTenthMicrosInMilliSecond = 10000;\par
813 \par
814   SYSTEMTIME now_systime;\par
815   FILETIME now_filetime;\par
816   ULARGE_INTEGER now_int64;\par
817   {\cf20 // TODO(kenton@google.com): Shouldn't this just use}\par
818   {\cf20 //   GetSystemTimeAsFileTime()?}\par
819   GetSystemTime(&now_systime);\par
820   {\cf19 if} (SystemTimeToFileTime(&now_systime, &now_filetime)) \{\par
821     now_int64.LowPart = now_filetime.dwLowDateTime;\par
822     now_int64.HighPart = now_filetime.dwHighDateTime;\par
823     now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -\par
824       kJavaEpochToWinFileTimeDelta;\par
825     {\cf19 return} now_int64.QuadPart;\par
826   \}\par
827   {\cf19 return} 0;\par
828 {\cf21 #elif GTEST_OS_WINDOWS && !GTEST_HAS_GETTIMEOFDAY_}\par
829   __timeb64 now;\par
830 \par
831   {\cf20 // MSVC 8 deprecates _ftime64(), so we want to suppress warning 4996}\par
832   {\cf20 // (deprecated function) there.}\par
833   {\cf20 // TODO(kenton@google.com): Use GetTickCount()?  Or use}\par
834   {\cf20 //   SystemTimeToFileTime()}\par
835   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\par
836   _ftime64(&now);\par
837   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
838 \par
839   return static_cast<TimeInMillis>(now.time) * 1000 + now.millitm;\par
840 {\cf21 #elif GTEST_HAS_GETTIMEOFDAY_}\par
841   {\cf17 struct }timeval now;\par
842   gettimeofday(&now, NULL);\par
843   {\cf19 return} {\cf17 static_cast<}TimeInMillis{\cf17 >}(now.tv_sec) * 1000 + now.tv_usec / 1000;\par
844 #{\cf19 else}\par
845 # error {\cf22 "Don't know how to get the current time on your system."}\par
846 #endif\par
847 \}\par
}
{
\ql
References GTEST_DISABLE_MSC_WARNINGS_POP_, GTEST_DISABLE_MSC_WARNINGS_PUSH_, and GTEST_HAS_GETTIMEOFDAY_.}\par
{
\ql
Referenced by GetRandomSeedFromFlag(), testing::TestInfo::Run(), testing::TestCase::Run(), and testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae66b46943a429e6efb1db456d4cae90c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GetTypeId\:testing::internal}
{\xe \v testing::internal\:GetTypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b TypeId} testing::internal::GetTypeId ()}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 447                    \{\par
448   {\cf20 // The compiler is required to allocate a different}\par
449   {\cf20 // TypeIdHelper<T>::dummy_ variable for each T used to instantiate}\par
450   {\cf20 // the template.  Therefore, the address of dummy_ is guaranteed to}\par
451   {\cf20 // be unique.}\par
452   {\cf19 return} &(TypeIdHelper<T>::dummy_);\par
453 \}\par
}
}
{\xe \v GetTypeName\:testing::internal}
{\xe \v testing::internal\:GetTypeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b std::string} testing::internal::GetTypeName ()}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 64                         \{\par
65 {\cf21 # if GTEST_HAS_RTTI}\par
66 \par
67   {\cf17 const} {\cf18 char}* {\cf17 const} name = {\cf17 typeid}(T).name();\par
68 {\cf21 #  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)}\par
69   {\cf18 int} status = 0;\par
70   {\cf20 // gcc's implementation of typeid(T).name() mangles the type name,}\par
71   {\cf20 // so we have to demangle it.}\par
72 {\cf21 #   if GTEST_HAS_CXXABI_H_}\par
73   {\cf17 using} abi::__cxa_demangle;\par
74 {\cf21 #   endif  }{\cf20 // GTEST_HAS_CXXABI_H_}\par
75   {\cf18 char}* {\cf17 const} readable_name = __cxa_demangle(name, 0, 0, &status);\par
76   {\cf17 const} std::string name_str(status == 0 ? readable_name : name);\par
77   free(readable_name);\par
78   {\cf19 return} name_str;\par
79 {\cf21 #  else}\par
80   {\cf19 return} name;\par
81 {\cf21 #  endif  }{\cf20 // GTEST_HAS_CXXABI_H_ || __HP_aCC}\par
82 \par
83 {\cf21 # else}\par
84 \par
85   {\cf19 return} {\cf22 "<type>"};\par
86 \par
87 {\cf21 # endif  }{\cf20 // GTEST_HAS_RTTI}\par
88 \}\par
}
}
{\xe \v GetUnitTestImpl\:testing::internal}
{\xe \v testing::internal\:GetUnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
class {\b UnitTestImpl} * testing::internal::GetUnitTestImpl ()}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 927                                        \{\par
928   {\cf19 return} UnitTest::GetInstance()->impl();\par
929 \}\par
}
{
\ql
References testing::UnitTest::GetInstance(), and testing::UnitTest::impl().}\par
{
\ql
Referenced by GetCurrentOsStackTraceExceptTop(), HandleExceptionsInMethodIfSupported(), testing::Test::HasFatalFailure(), testing::internal::HasNewFatalFailureHelper::HasNewFatalFailureHelper(), testing::Test::HasNonfatalFailure(), testing::Test::HasSameFixtureClass(), testing::ScopedFakeTestPartResultReporter::Init(), InitGoogleTestImpl(), MakeAndRegisterTestInfo(), testing::Test::Run(), testing::TestInfo::Run(), testing::TestCase::Run(), testing::internal::HasNewFatalFailureHelper::~HasNewFatalFailureHelper(), and testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a18ef697b64e28a78625c7a53cf28344c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a18ef697b64e28a78625c7a53cf28344c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v GTEST_DECLARE_STATIC_MUTEX_\:testing::internal}
{\xe \v testing::internal\:GTEST_DECLARE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} testing::internal::GTEST_DECLARE_STATIC_MUTEX_ (g_linked_ptr_mutex )}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing::internal}
{\xe \v testing::internal\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_DECLARE_string_ (internal_run_death_test )}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_STATIC_MUTEX_\:testing::internal}
{\xe \v testing::internal\:GTEST_DEFINE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} testing::internal::GTEST_DEFINE_STATIC_MUTEX_ (g_linked_ptr_mutex )}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing::internal}
{\xe \v testing::internal\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_DEFINE_string_ (internal_run_death_test , "" , "Indicates the  {\i file}, line  {\i number}, temporal index of " "the single death test to  {\i run}, and a file descriptor to " "which a success code may be  {\i sent}, all separated by " "the '|' characters. This flag is specified if and only if the current " "process is a sub-process launched for running a thread-safe " "death test. FOR INTERNAL USE ONLY." )}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (GE , >= )}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (GT )}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (LE , <= )}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (LT )}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (NE , ! )}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_ (char )}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_ (wchar_t )}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_STRING_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_STRING_ (char , ::{\b std::string} )}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTestIsInitialized\:testing::internal}
{\xe \v testing::internal\:GTestIsInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::GTestIsInitialized (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 330 \{ {\cf19 return} GetArgvs().size() > 0; \}\par
}
{
\ql
References GetArgvs().}\par
{
\ql
Referenced by InitGoogleTestImpl(), and testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a91e707e0d371fae0224ffd37f0d042af_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a91e707e0d371fae0224ffd37f0d042af_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v HandleExceptionsInMethodIfSupported\:testing::internal}
{\xe \v testing::internal\:HandleExceptionsInMethodIfSupported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T , typename Result > Result testing::internal::HandleExceptionsInMethodIfSupported (T *  {\i object}, Result(T::*)()  {\i method}, const char *  {\i location})}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2411                                                           \{\par
2412   {\cf20 // NOTE: The user code can affect the way in which Google Test handles}\par
2413   {\cf20 // exceptions by setting GTEST_FLAG(catch_exceptions), but only before}\par
2414   {\cf20 // RUN_ALL_TESTS() starts. It is technically possible to check the flag}\par
2415   {\cf20 // after the exception is caught and either report or re-throw the}\par
2416   {\cf20 // exception based on the flag's value:}\par
2417   {\cf20 //}\par
2418   {\cf20 // try \{}\par
2419   {\cf20 //   // Perform the test method.}\par
2420   {\cf20 // \} catch (...) \{}\par
2421   {\cf20 //   if (GTEST_FLAG(catch_exceptions))}\par
2422   {\cf20 //     // Report the exception as failure.}\par
2423   {\cf20 //   else}\par
2424   {\cf20 //     throw;  // Re-throws the original exception.}\par
2425   {\cf20 // \}}\par
2426   {\cf20 //}\par
2427   {\cf20 // However, the purpose of this flag is to allow the program to drop into}\par
2428   {\cf20 // the debugger when the exception is thrown. On most platforms, once the}\par
2429   {\cf20 // control enters the catch block, the exception origin information is}\par
2430   {\cf20 // lost and the debugger will stop the program at the point of the}\par
2431   {\cf20 // re-throw in this function -- instead of at the point of the original}\par
2432   {\cf20 // throw statement in the code under test.  For this reason, we perform}\par
2433   {\cf20 // the check early, sacrificing the ability to affect Google Test's}\par
2434   {\cf20 // exception handling in the method where the exception is thrown.}\par
2435   {\cf19 if} (internal::GetUnitTestImpl()->catch_exceptions()) \{\par
2436 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
2437     {\cf19 try} \{\par
2438       {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
2439     \} {\cf19 catch} ({\cf17 const} internal::GoogleTestFailureException&) \{  {\cf20 // NOLINT}\par
2440       {\cf20 // This exception type can only be thrown by a failed Google}\par
2441       {\cf20 // Test assertion with the intention of letting another testing}\par
2442       {\cf20 // framework catch it.  Therefore we just re-throw it.}\par
2443       {\cf19 throw};\par
2444     \} {\cf19 catch} ({\cf17 const} std::exception& e) \{  {\cf20 // NOLINT}\par
2445       internal::ReportFailureInUnknownLocation(\par
2446           TestPartResult::kFatalFailure,\par
2447           FormatCxxExceptionMessage(e.what(), location));\par
2448     \} {\cf19 catch} (...) \{  {\cf20 // NOLINT}\par
2449       internal::ReportFailureInUnknownLocation(\par
2450           TestPartResult::kFatalFailure,\par
2451           FormatCxxExceptionMessage(NULL, location));\par
2452     \}\par
2453     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
2454 {\cf21 #else}\par
2455     {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
2456 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
2457   \} {\cf19 else} \{\par
2458     {\cf19 return} (object->*method)();\par
2459   \}\par
2460 \}\par
}
{
\ql
References GetUnitTestImpl(), HandleSehExceptionsInMethodIfSupported(), testing::TestPartResult::kFatalFailure, ReportFailureInUnknownLocation(), and std::exception::what().}\par
{
\ql
Referenced by testing::Test::Run(), testing::TestInfo::Run(), testing::TestCase::Run(), and testing::UnitTest::Run().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_addb2ed165b92b74e25fe9ebe9e46b9f9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_addb2ed165b92b74e25fe9ebe9e46b9f9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v HandleSehExceptionsInMethodIfSupported\:testing::internal}
{\xe \v testing::internal\:HandleSehExceptionsInMethodIfSupported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T , typename Result > Result testing::internal::HandleSehExceptionsInMethodIfSupported (T *  {\i object}, Result(T::*)()  {\i method}, const char *  {\i location})}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2384                                                           \{\par
2385 {\cf21 #if GTEST_HAS_SEH}\par
2386   __try \{\par
2387     {\cf19 return} (object->*method)();\par
2388   \} __except (internal::UnitTestOptions::GTestShouldProcessSEH(  {\cf20 // NOLINT}\par
2389       GetExceptionCode())) \{\par
2390     {\cf20 // We create the exception message on the heap because VC++ prohibits}\par
2391     {\cf20 // creation of objects with destructors on stack in functions using __try}\par
2392     {\cf20 // (see error C2712).}\par
2393     std::string* exception_message = FormatSehExceptionMessage(\par
2394         GetExceptionCode(), location);\par
2395     internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,\par
2396                                              *exception_message);\par
2397     {\cf17 delete} exception_message;\par
2398     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
2399   \}\par
2400 {\cf21 #else}\par
2401   (void)location;\par
2402   {\cf19 return} (object->*method)();\par
2403 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
2404 \}\par
}
{
\ql
References testing::TestPartResult::kFatalFailure, and ReportFailureInUnknownLocation().}\par
{
\ql
Referenced by HandleExceptionsInMethodIfSupported().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac5293b438139ef7ed05cb7fcaaf63545_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac5293b438139ef7ed05cb7fcaaf63545_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v HasGoogleTestFlagPrefix\:testing::internal}
{\xe \v testing::internal\:HasGoogleTestFlagPrefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::HasGoogleTestFlagPrefix (const char *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5105                                                      \{\par
5106   {\cf19 return} (SkipPrefix({\cf22 "--"}, &str) ||\par
5107           SkipPrefix({\cf22 "-"}, &str) ||\par
5108           SkipPrefix({\cf22 "/"}, &str)) &&\par
5109          !SkipPrefix(GTEST_FLAG_PREFIX_ {\cf22 "internal_"}, &str) &&\par
5110          (SkipPrefix(GTEST_FLAG_PREFIX_, &str) ||\par
5111           SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &str));\par
5112 \}\par
}
{
\ql
References GTEST_FLAG_PREFIX_, GTEST_FLAG_PREFIX_DASH_, and SkipPrefix().}\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6fff795269f50673e358438721710d6f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6fff795269f50673e358438721710d6f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v HasOneFailure\:testing::internal}
{\xe \v testing::internal\:HasOneFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::HasOneFailure (const char * , const char * , const char * , const {\b TestPartResultArray} &  {\i results}, {\b TestPartResult::Type}  {\i type}, const {\b string} &  {\i substr})}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 636                                                     \{\par
637   {\cf17 const} std::string expected(type == TestPartResult::kFatalFailure ?\par
638                         {\cf22 "1 fatal failure"} :\par
639                         {\cf22 "1 non-fatal failure"});\par
640   Message msg;\par
641   {\cf19 if} (results.size() != 1) \{\par
642     msg << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
643         << {\cf22 "  Actual: "} << results.size() << {\cf22 " failures"};\par
644     {\cf19 for} ({\cf18 int} i = 0; i < results.size(); i++) \{\par
645       msg << {\cf22 "\\n"} << results.GetTestPartResult(i);\par
646     \}\par
647     {\cf19 return} AssertionFailure() << msg;\par
648   \}\par
649 \par
650   {\cf17 const} TestPartResult& r = results.GetTestPartResult(0);\par
651   {\cf19 if} (r.type() != type) \{\par
652     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
653                               << {\cf22 "  Actual:\\n"}\par
654                               << r;\par
655   \}\par
656 \par
657   {\cf19 if} (strstr(r.message(), substr.c_str()) == NULL) \{\par
658     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 " containing \\""}\par
659                               << substr << {\cf22 "\\"\\n"}\par
660                               << {\cf22 "  Actual:\\n"}\par
661                               << r;\par
662   \}\par
663 \par
664   {\cf19 return} AssertionSuccess();\par
665 \}\par
}
{
\ql
References testing::AssertionFailure(), testing::AssertionSuccess(), std::string::c_str(), testing::TestPartResultArray::GetTestPartResult(), testing::TestPartResult::kFatalFailure, testing::TestPartResult::message(), testing::TestPartResultArray::size(), and testing::TestPartResult::type().}\par
{
\ql
Referenced by testing::internal::SingleFailureChecker::~SingleFailureChecker().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a14ff02e6d151f45e998657674e9af88a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a14ff02e6d151f45e998657674e9af88a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ImplicitCast_\:testing::internal}
{\xe \v testing::internal\:ImplicitCast_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename To > To testing::internal::ImplicitCast_ (To  {\i x})}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1343 \{ {\cf19 return} x; \}\par
}
}
{\xe \v InitGoogleTestImpl\:testing::internal}
{\xe \v testing::internal\:InitGoogleTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void testing::internal::InitGoogleTestImpl (int *  {\i argc}, CharType **  {\i argv})}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5344                                                     \{\par
5345   {\cf20 // We don't want to run the initialization code twice.}\par
5346   {\cf19 if} (GTestIsInitialized()) {\cf19 return};\par
5347 \par
5348   {\cf19 if} (*argc <= 0) {\cf19 return};\par
5349 \par
5350   g_argvs.clear();\par
5351   {\cf19 for} ({\cf18 int} i = 0; i != *argc; i++) \{\par
5352     g_argvs.push_back(StreamableToString(argv[i]));\par
5353   \}\par
5354 \par
5355   ParseGoogleTestFlagsOnly(argc, argv);\par
5356   GetUnitTestImpl()->PostFlagParsingInit();\par
5357 \}\par
}
{
\ql
References g_argvs, GetUnitTestImpl(), GTestIsInitialized(), ParseGoogleTestFlagsOnly(), testing::internal::UnitTestImpl::PostFlagParsingInit(), and StreamableToString().}\par
{
\ql
Referenced by testing::InitGoogleTest().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac3c6fa93391768aa91c6238b31aaeeb5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac3c6fa93391768aa91c6238b31aaeeb5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Int32FromEnvOrDie\:testing::internal}
{\xe \v testing::internal\:Int32FromEnvOrDie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int32} testing::internal::Int32FromEnvOrDie (const char *  {\i env_var}, {\b Int32}  {\i default_val})}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4760                                                             \{\par
4761   {\cf17 const} {\cf18 char}* str_val = posix::GetEnv(var);\par
4762   {\cf19 if} (str_val == NULL) \{\par
4763     {\cf19 return} default_val;\par
4764   \}\par
4765 \par
4766   Int32 result;\par
4767   {\cf19 if} (!ParseInt32(Message() << {\cf22 "The value of environment variable "} << var,\par
4768                   str_val, &result)) \{\par
4769     exit(EXIT_FAILURE);\par
4770   \}\par
4771   {\cf19 return} result;\par
4772 \}\par
}
{
\ql
References testing::internal::posix::GetEnv(), and ParseInt32().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::FilterTests(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(), and ShouldShard().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aaa576613655c2f380278c255c3ec5fef_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aaa576613655c2f380278c255c3ec5fef_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Int32FromGTestEnv\:testing::internal}
{\xe \v testing::internal\:Int32FromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b Int32} testing::internal::Int32FromGTestEnv (const char *  {\i flag}, {\b Int32}  {\i default_value})}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1204                                                                \{\par
1205 {\cf21 #if defined(GTEST_GET_INT32_FROM_ENV_)}\par
1206   {\cf19 return} GTEST_GET_INT32_FROM_ENV_(flag, default_value);\par
1207 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_INT32_FROM_ENV_)}\par
1208   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
1209   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
1210   {\cf19 if} (string_value == NULL) \{\par
1211     {\cf20 // The environment variable is not set.}\par
1212     {\cf19 return} default_value;\par
1213   \}\par
1214 \par
1215   Int32 result = default_value;\par
1216   {\cf19 if} (!ParseInt32(Message() << {\cf22 "Environment variable "} << env_var,\par
1217                   string_value, &result)) \{\par
1218     printf({\cf22 "The default value %s is used.\\n"},\par
1219            (Message() << default_value).GetString().c_str());\par
1220     fflush(stdout);\par
1221     {\cf19 return} default_value;\par
1222   \}\par
1223 \par
1224   {\cf19 return} result;\par
1225 \}\par
}
{
\ql
References std::string::c_str(), FlagToEnvVar(), testing::internal::posix::GetEnv(), and ParseInt32().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a2196f070b2d28bceb45c7ad3b565b9ba_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsAlNum\:testing::internal}
{\xe \v testing::internal\:IsAlNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsAlNum (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2254                              \{\par
2255   {\cf19 return} isalnum({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2256 \}\par
}
}
{\xe \v IsAlpha\:testing::internal}
{\xe \v testing::internal\:IsAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsAlpha (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2251                              \{\par
2252   {\cf19 return} isalpha({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2253 \}\par
}
}
{\xe \v IsContainerTest\:testing::internal}
{\xe \v testing::internal\:IsContainerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class C > {\b IsContainer} testing::internal::IsContainerTest (int , typename C::iterator *  = {\f2 NULL}, typename C::const_iterator *  = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 934                                                                 \{\par
935   {\cf19 return} 0;\par
936 \}\par
}
}
{\xe \v IsContainerTest\:testing::internal}
{\xe \v testing::internal\:IsContainerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class C > {\b IsNotContainer} testing::internal::IsContainerTest (long )}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 940 \{ {\cf19 return} {\cf23 '\\0'}; \}\par
}
}
{\xe \v IsDigit\:testing::internal}
{\xe \v testing::internal\:IsDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsDigit (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2257                              \{\par
2258   {\cf19 return} isdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2259 \}\par
}
}
{\xe \v IsLower\:testing::internal}
{\xe \v testing::internal\:IsLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsLower (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2260                              \{\par
2261   {\cf19 return} islower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2262 \}\par
}
}
{\xe \v IsNullLiteralHelper\:testing::internal}
{\xe \v testing::internal\:IsNullLiteralHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char(& testing::internal::IsNullLiteralHelper (  {\i ...}))[2]}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsNullLiteralHelper\:testing::internal}
{\xe \v testing::internal\:IsNullLiteralHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::IsNullLiteralHelper (Secret *  {\i p})}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsPathSeparator\:testing::internal}
{\xe \v testing::internal\:IsPathSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::IsPathSeparator (char  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 90                                     \{\par
91 {\cf21 #if GTEST_HAS_ALT_PATH_SEP_}\par
92   {\cf19 return} (c == kPathSeparator) || (c == kAlternatePathSeparator);\par
93 {\cf21 #else}\par
94   {\cf19 return} c == kPathSeparator;\par
95 {\cf21 #endif}\par
96 \}\par
}
{
\ql
References kPathSeparator.}\par
{
\ql
Referenced by testing::internal::FilePath::IsAbsolutePath(), testing::internal::FilePath::IsDirectory(), testing::internal::FilePath::IsRootDirectory(), and testing::internal::FilePath::Normalize().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6b8d22cee9edbbfe56077420a6fa1cb1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsPrintableAscii\:testing::internal}
{\xe \v testing::internal\:IsPrintableAscii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsPrintableAscii (wchar_t  {\i c})}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 137                                         \{\par
138   {\cf19 return} 0x20 <= c && c <= 0x7E;\par
139 \}\par
}
{
\ql
Referenced by PrintAsCharLiteralTo().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a744a6dd74c12d1e2c16b3c03e14ed4d4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsSpace\:testing::internal}
{\xe \v testing::internal\:IsSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsSpace (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2263                              \{\par
2264   {\cf19 return} isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2265 \}\par
}
{
\ql
Referenced by StripTrailingSpaces().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af429e04f70f9c10f6aa76a5d1ccd389f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsTrue\:testing::internal}
{\xe \v testing::internal\:IsTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} bool testing::internal::IsTrue (bool  {\i condition})}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4986 \{ {\cf19 return} condition; \}\par
}
{
\ql
Referenced by AlwaysTrue(), DefaultPrintTo(), and testing::internal::scoped_ptr< T >::reset().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab2709373c78eb8b1c22a6ba30cceba52_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsUpper\:testing::internal}
{\xe \v testing::internal\:IsUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsUpper (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2266                              \{\par
2267   {\cf19 return} isupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2268 \}\par
}
}
{\xe \v IsUtf16SurrogatePair\:testing::internal}
{\xe \v testing::internal\:IsUtf16SurrogatePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsUtf16SurrogatePair (wchar_t  {\i first}, wchar_t  {\i second})}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1794                                                                 \{\par
1795   {\cf19 return} {\cf17 sizeof}(wchar_t) == 2 &&\par
1796       (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;\par
1797 \}\par
}
{
\ql
Referenced by WideStringToUtf8().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a681895f8cc32286211be9889da107394_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsXDigit\:testing::internal}
{\xe \v testing::internal\:IsXDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsXDigit (char  {\i ch})}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2269                               \{\par
2270   {\cf19 return} isxdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
2271 \}\par
}
{
\ql
Referenced by PrintCharsAsStringTo().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa234ef141278263fb143b616c74c86e7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IsXDigit\:testing::internal}
{\xe \v testing::internal\:IsXDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsXDigit (wchar_t  {\i ch})}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2272                                  \{\par
2273   {\cf17 const} {\cf18 unsigned} {\cf18 char} low_byte = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch);\par
2274   {\cf19 return} ch == low_byte && isxdigit(low_byte) != 0;\par
2275 \}\par
}
}
{\xe \v LogToStderr\:testing::internal}
{\xe \v testing::internal\:LogToStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::LogToStderr ()}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1275 \{\}\par
}
}
{\xe \v make_linked_ptr\:testing::internal}
{\xe \v testing::internal\:make_linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b linked_ptr}<T> testing::internal::make_linked_ptr (T *  {\i ptr})}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 236                                       \{\par
237   {\cf19 return} linked_ptr<T>(ptr);\par
238 \}\par
}
}
{\xe \v MakeAndRegisterTestInfo\:testing::internal}
{\xe \v testing::internal\:MakeAndRegisterTestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b TestInfo} * testing::internal::MakeAndRegisterTestInfo (const char *  {\i test_case_name}, const char *  {\i name}, const char *  {\i type_param}, const char *  {\i value_param}, {\b CodeLocation}  {\i code_location}, {\b TypeId}  {\i fixture_class_id}, {\b SetUpTestCaseFunc}  {\i set_up_tc}, {\b TearDownTestCaseFunc}  {\i tear_down_tc}, {\b TestFactoryBase} *  {\i factory})}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2552                               \{\par
2553   TestInfo* {\cf17 const} test_info =\par
2554       {\cf17 new} TestInfo(test_case_name, name, type_param, value_param,\par
2555                    code_location, fixture_class_id, factory);\par
2556   GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\par
2557   {\cf19 return} test_info;\par
2558 \}\par
}
{
\ql
References testing::internal::UnitTestImpl::AddTestInfo(), and GetUnitTestImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a082a431211a960763865897fecb7cb27_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v move\:testing::internal}
{\xe \v testing::internal\:move}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T& testing::internal::move (const T &  {\i t})}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1317                           \{\par
1318   {\cf19 return} t;\par
1319 \}\par
}
{
\ql
Referenced by testing::internal::edit_distance::CalculateOptimalEdits().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0f6d06bf8c3093b9c22bb08723db201e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:testing::internal}
{\xe \v testing::internal\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool testing::internal::operator!= (T *  {\i ptr}, const {\b linked_ptr}< T > &  {\i x})}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 228                                                 \{\par
229   {\cf19 return} ptr != x.get();\par
230 \}\par
}
{
\ql
References testing::internal::linked_ptr< T >::get().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a6910869259f8f31825b471e9190fa09a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator==\:testing::internal}
{\xe \v testing::internal\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool testing::internal::operator== (T *  {\i ptr}, const {\b linked_ptr}< T > &  {\i x})}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 223                                                 \{\par
224   {\cf19 return} ptr == x.get();\par
225 \}\par
}
{
\ql
References testing::internal::linked_ptr< T >::get().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad1cb54a206a209ddace17a05359d38ae_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseBoolFlag\:testing::internal}
{\xe \v testing::internal\:ParseBoolFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseBoolFlag (const char *  {\i str}, const char *  {\i flag}, bool *  {\i value})}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5053                                                                    \{\par
5054   {\cf20 // Gets the value of the flag as a string.}\par
5055   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 true});\par
5056 \par
5057   {\cf20 // Aborts if the parsing failed.}\par
5058   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
5059 \par
5060   {\cf20 // Converts the string value to a bool.}\par
5061   *value = !(*value_str == {\cf23 '0'} || *value_str == {\cf23 'f'} || *value_str == {\cf23 'F'});\par
5062   {\cf19 return} {\cf17 true};\par
5063 \}\par
}
{
\ql
References ParseFlagValue().}\par
{
\ql
Referenced by ParseGoogleTestFlag(), and ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ada3b98e7cfe93f4ba2053c470d9e3e51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ada3b98e7cfe93f4ba2053c470d9e3e51_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseFlagValue\:testing::internal}
{\xe \v testing::internal\:ParseFlagValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* testing::internal::ParseFlagValue (const char *  {\i str}, const char *  {\i flag}, bool  {\i def_optional})}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5017                                               \{\par
5018   {\cf20 // str and flag must not be NULL.}\par
5019   {\cf19 if} (str == NULL || flag == NULL) {\cf19 return} NULL;\par
5020 \par
5021   {\cf20 // The flag must start with "--" followed by GTEST_FLAG_PREFIX_.}\par
5022   {\cf17 const} std::string flag_str = std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + flag;\par
5023   {\cf17 const} {\cf18 size_t} flag_len = flag_str.length();\par
5024   {\cf19 if} (strncmp(str, flag_str.c_str(), flag_len) != 0) {\cf19 return} NULL;\par
5025 \par
5026   {\cf20 // Skips the flag name.}\par
5027   {\cf17 const} {\cf18 char}* flag_end = str + flag_len;\par
5028 \par
5029   {\cf20 // When def_optional is true, it's OK to not have a "=value" part.}\par
5030   {\cf19 if} (def_optional && (flag_end[0] == {\cf23 '\\0'})) \{\par
5031     {\cf19 return} flag_end;\par
5032   \}\par
5033 \par
5034   {\cf20 // If def_optional is true and there are more characters after the}\par
5035   {\cf20 // flag name, or if def_optional is false, there must be a '=' after}\par
5036   {\cf20 // the flag name.}\par
5037   {\cf19 if} (flag_end[0] != {\cf23 '='}) {\cf19 return} NULL;\par
5038 \par
5039   {\cf20 // Returns the string after "=".}\par
5040   {\cf19 return} flag_end + 1;\par
5041 \}\par
}
{
\ql
References std::string::c_str(), GTEST_FLAG_PREFIX_, and std::string::length().}\par
{
\ql
Referenced by ParseBoolFlag(), ParseInt32Flag(), and ParseStringFlag().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a8bfd56af5e4a89bfb76f7e1723e41b03_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a8bfd56af5e4a89bfb76f7e1723e41b03_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseGoogleTestFlag\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseGoogleTestFlag (const char *const  {\i arg})}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5223                                                 \{\par
5224   {\cf19 return} ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,\par
5225                        &GTEST_FLAG(also_run_disabled_tests)) ||\par
5226       ParseBoolFlag(arg, kBreakOnFailureFlag,\par
5227                     &GTEST_FLAG(break_on_failure)) ||\par
5228       ParseBoolFlag(arg, kCatchExceptionsFlag,\par
5229                     &GTEST_FLAG(catch_exceptions)) ||\par
5230       ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||\par
5231       ParseStringFlag(arg, kDeathTestStyleFlag,\par
5232                       &GTEST_FLAG(death_test_style)) ||\par
5233       ParseBoolFlag(arg, kDeathTestUseFork,\par
5234                     &GTEST_FLAG(death_test_use_fork)) ||\par
5235       ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||\par
5236       ParseStringFlag(arg, kInternalRunDeathTestFlag,\par
5237                       &GTEST_FLAG(internal_run_death_test)) ||\par
5238       ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||\par
5239       ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||\par
5240       ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||\par
5241       ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||\par
5242       ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||\par
5243       ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||\par
5244       ParseInt32Flag(arg, kStackTraceDepthFlag,\par
5245                      &GTEST_FLAG(stack_trace_depth)) ||\par
5246       ParseStringFlag(arg, kStreamResultToFlag,\par
5247                       &GTEST_FLAG(stream_result_to)) ||\par
5248       ParseBoolFlag(arg, kThrowOnFailureFlag,\par
5249                     &GTEST_FLAG(throw_on_failure));\par
5250 \}\par
}
{
\ql
References GTEST_FLAG, kAlsoRunDisabledTestsFlag, kBreakOnFailureFlag, kCatchExceptionsFlag, kColorFlag, kDeathTestStyleFlag, kDeathTestUseFork, kFilterFlag, kInternalRunDeathTestFlag, kListTestsFlag, kOutputFlag, kPrintTimeFlag, kRandomSeedFlag, kRepeatFlag, kShuffleFlag, kStackTraceDepthFlag, kStreamResultToFlag, kThrowOnFailureFlag, ParseBoolFlag(), ParseInt32Flag(), and ParseStringFlag().}\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_afccff08aa2b1ede0dd32c1364a5dee42_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_afccff08aa2b1ede0dd32c1364a5dee42_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseGoogleTestFlagsOnly\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ParseGoogleTestFlagsOnly (int *  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5332                                                       \{\par
5333   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
5334 \}\par
}
{
\ql
References ParseGoogleTestFlagsOnlyImpl().}\par
{
\ql
Referenced by InitGoogleTestImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a472880afbcc592a41e3d623e2dec8412_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a472880afbcc592a41e3d623e2dec8412_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseGoogleTestFlagsOnly\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ParseGoogleTestFlagsOnly (int *  {\i argc}, wchar_t **  {\i argv})}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5335                                                          \{\par
5336   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
5337 \}\par
}
{
\ql
References ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa3c81a67914856448d0778990d9d9cab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseGoogleTestFlagsOnlyImpl\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnlyImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void testing::internal::ParseGoogleTestFlagsOnlyImpl (int *  {\i argc}, CharType **  {\i argv})}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5279                                                               \{\par
5280   {\cf19 for} ({\cf18 int} i = 1; i < *argc; i++) \{\par
5281     {\cf17 const} std::string arg_string = StreamableToString(argv[i]);\par
5282     {\cf17 const} {\cf18 char}* {\cf17 const} arg = arg_string.c_str();\par
5283 \par
5284     {\cf17 using} internal::ParseBoolFlag;\par
5285     {\cf17 using} internal::ParseInt32Flag;\par
5286     {\cf17 using} internal::ParseStringFlag;\par
5287 \par
5288     {\cf18 bool} remove_flag = {\cf17 false};\par
5289     {\cf19 if} (ParseGoogleTestFlag(arg)) \{\par
5290       remove_flag = {\cf17 true};\par
5291 {\cf21 #if GTEST_USE_OWN_FLAGFILE_FLAG_}\par
5292     \} {\cf19 else} {\cf19 if} (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) \{\par
5293       LoadFlagsFromFile(GTEST_FLAG(flagfile));\par
5294       remove_flag = {\cf17 true};\par
5295 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_FLAGFILE_FLAG_}\par
5296     \} {\cf19 else} {\cf19 if} (arg_string == {\cf22 "--help"} || arg_string == {\cf22 "-h"} ||\par
5297                arg_string == {\cf22 "-?"} || arg_string == {\cf22 "/?"} ||\par
5298                HasGoogleTestFlagPrefix(arg)) \{\par
5299       {\cf20 // Both help flag and unrecognized Google Test flags (excluding}\par
5300       {\cf20 // internal ones) trigger help display.}\par
5301       g_help_flag = {\cf17 true};\par
5302     \}\par
5303 \par
5304     {\cf19 if} (remove_flag) \{\par
5305       {\cf20 // Shift the remainder of the argv list left by one.  Note}\par
5306       {\cf20 // that argv has (*argc + 1) elements, the last one always being}\par
5307       {\cf20 // NULL.  The following loop moves the trailing NULL element as}\par
5308       {\cf20 // well.}\par
5309       {\cf19 for} ({\cf18 int} j = i; j != *argc; j++) \{\par
5310         argv[j] = argv[j + 1];\par
5311       \}\par
5312 \par
5313       {\cf20 // Decrements the argument count.}\par
5314       (*argc)--;\par
5315 \par
5316       {\cf20 // We also need to decrement the iterator as we just removed}\par
5317       {\cf20 // an element.}\par
5318       i--;\par
5319     \}\par
5320   \}\par
5321 \par
5322   {\cf19 if} (g_help_flag) \{\par
5323     {\cf20 // We print the help here instead of in RUN_ALL_TESTS(), as the}\par
5324     {\cf20 // latter may not be called at all if the user is using Google}\par
5325     {\cf20 // Test with another testing framework.}\par
5326     PrintColorEncoded(kColorEncodedHelpMessage);\par
5327   \}\par
5328 \}\par
}
{
\ql
References std::string::c_str(), g_help_flag, GTEST_FLAG, HasGoogleTestFlagPrefix(), kColorEncodedHelpMessage, kFlagfileFlag, ParseBoolFlag(), ParseGoogleTestFlag(), ParseInt32Flag(), ParseStringFlag(), PrintColorEncoded(), and StreamableToString().}\par
{
\ql
Referenced by ParseGoogleTestFlagsOnly().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae4c46ce8c3d016848fff52cc5133f2ac_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae4c46ce8c3d016848fff52cc5133f2ac_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseInt32\:testing::internal}
{\xe \v testing::internal\:ParseInt32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseInt32 (const {\b Message} &  {\i src_text}, const char *  {\i str}, {\b Int32} *  {\i value})}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1149                                                                         \{\par
1150   {\cf20 // Parses the environment variable as a decimal integer.}\par
1151   {\cf18 char}* end = NULL;\par
1152   {\cf17 const} {\cf18 long} long_value = strtol(str, &end, 10);  {\cf20 // NOLINT}\par
1153 \par
1154   {\cf20 // Has strtol() consumed all characters in the string?}\par
1155   {\cf19 if} (*end != {\cf23 '\\0'}) \{\par
1156     {\cf20 // No - an invalid character was encountered.}\par
1157     Message msg;\par
1158     msg << {\cf22 "WARNING: "} << src_text\par
1159         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
1160         << {\cf22 " has value \\""} << str << {\cf22 "\\".\\n"};\par
1161     printf({\cf22 "%s"}, msg.GetString().c_str());\par
1162     fflush(stdout);\par
1163     {\cf19 return} {\cf17 false};\par
1164   \}\par
1165 \par
1166   {\cf20 // Is the parsed value in the range of an Int32?}\par
1167   {\cf17 const} Int32 result = {\cf17 static_cast<}Int32{\cf17 >}(long_value);\par
1168   {\cf19 if} (long_value == LONG_MAX || long_value == LONG_MIN ||\par
1169       {\cf20 // The parsed value overflows as a long.  (strtol() returns}\par
1170       {\cf20 // LONG_MAX or LONG_MIN when the input overflows.)}\par
1171       result != long_value\par
1172       {\cf20 // The parsed value overflows as an Int32.}\par
1173       ) \{\par
1174     Message msg;\par
1175     msg << {\cf22 "WARNING: "} << src_text\par
1176         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
1177         << {\cf22 " has value "} << str << {\cf22 ", which overflows.\\n"};\par
1178     printf({\cf22 "%s"}, msg.GetString().c_str());\par
1179     fflush(stdout);\par
1180     {\cf19 return} {\cf17 false};\par
1181   \}\par
1182 \par
1183   *value = result;\par
1184   {\cf19 return} {\cf17 true};\par
1185 \}\par
}
{
\ql
References std::string::c_str(), and testing::Message::GetString().}\par
{
\ql
Referenced by Int32FromEnvOrDie(), Int32FromGTestEnv(), and ParseInt32Flag().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac06fc81336a3d80755f4020d34321766_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac06fc81336a3d80755f4020d34321766_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseInt32Flag\:testing::internal}
{\xe \v testing::internal\:ParseInt32Flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseInt32Flag (const char *  {\i str}, const char *  {\i flag}, {\b Int32} *  {\i value})}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5070                                                                      \{\par
5071   {\cf20 // Gets the value of the flag as a string.}\par
5072   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
5073 \par
5074   {\cf20 // Aborts if the parsing failed.}\par
5075   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
5076 \par
5077   {\cf20 // Sets *value to the value of the flag.}\par
5078   {\cf19 return} ParseInt32(Message() << {\cf22 "The value of flag --"} << flag,\par
5079                     value_str, value);\par
5080 \}\par
}
{
\ql
References ParseFlagValue(), and ParseInt32().}\par
{
\ql
Referenced by ParseGoogleTestFlag(), and ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae3449e173767750b613114ceac6d916a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ae3449e173767750b613114ceac6d916a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ParseStringFlag\:testing::internal}
{\xe \v testing::internal\:ParseStringFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseStringFlag (const char *  {\i str}, const char *  {\i flag}, {\b std::string} *  {\i value})}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5087                                                                           \{\par
5088   {\cf20 // Gets the value of the flag as a string.}\par
5089   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
5090 \par
5091   {\cf20 // Aborts if the parsing failed.}\par
5092   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
5093 \par
5094   {\cf20 // Sets *value to the value of the flag.}\par
5095   *value = value_str;\par
5096   {\cf19 return} {\cf17 true};\par
5097 \}\par
}
{
\ql
References ParseFlagValue().}\par
{
\ql
Referenced by ParseGoogleTestFlag(), and ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa4ce312efaaf7a97aac2303173afe021_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa4ce312efaaf7a97aac2303173afe021_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PortableLocaltime\:testing::internal}
{\xe \v testing::internal\:PortableLocaltime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::PortableLocaltime (time_t  {\i seconds}, struct tm *  {\i out}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3556                                                               \{\par
3557 {\cf21 #if defined(_MSC_VER)}\par
3558   {\cf19 return} localtime_s(out, &seconds) == 0;\par
3559 {\cf21 #elif defined(__MINGW32__) || defined(__MINGW64__)}\par
3560   {\cf20 // MINGW <time.h> provides neither localtime_r nor localtime_s, but uses}\par
3561   {\cf20 // Windows' localtime(), which has a thread-local tm buffer.}\par
3562   {\cf17 struct }tm* tm_ptr = localtime(&seconds);  {\cf20 // NOLINT}\par
3563   {\cf19 if} (tm_ptr == NULL)\par
3564     {\cf19 return} {\cf17 false};\par
3565   *out = *tm_ptr;\par
3566   {\cf19 return} {\cf17 true};\par
3567 {\cf21 #else}\par
3568   {\cf19 return} localtime_r(&seconds, out) != NULL;\par
3569 {\cf21 #endif}\par
3570 \}\par
}
{
\ql
Referenced by FormatEpochTimeInMillisAsIso8601().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a60af94307ed4f00a57b5c6d9617c046d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintAsCharLiteralTo\:testing::internal}
{\xe \v testing::internal\:PrintAsCharLiteralTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UnsignedChar , typename Char > static {\b CharFormat} testing::internal::PrintAsCharLiteralTo (Char  {\i c}, ostream *  {\i os}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 146                                                             \{\par
147   {\cf19 switch} ({\cf17 static_cast<}{\cf18 wchar_t}{\cf17 >}(c)) \{\par
148     {\cf19 case} L{\cf23 '\\0'}:\par
149       *os << {\cf22 "\\\\0"};\par
150       {\cf19 break};\par
151     {\cf19 case} L{\cf23 '\\''}:\par
152       *os << {\cf22 "\\\\'"};\par
153       {\cf19 break};\par
154     {\cf19 case} L{\cf23 '\\\\'}:\par
155       *os << {\cf22 "\\\\\\\\"};\par
156       {\cf19 break};\par
157     {\cf19 case} L{\cf23 '\\a'}:\par
158       *os << {\cf22 "\\\\a"};\par
159       {\cf19 break};\par
160     {\cf19 case} L{\cf23 '\\b'}:\par
161       *os << {\cf22 "\\\\b"};\par
162       {\cf19 break};\par
163     {\cf19 case} L{\cf23 '\\f'}:\par
164       *os << {\cf22 "\\\\f"};\par
165       {\cf19 break};\par
166     {\cf19 case} L{\cf23 '\\n'}:\par
167       *os << {\cf22 "\\\\n"};\par
168       {\cf19 break};\par
169     {\cf19 case} L{\cf23 '\\r'}:\par
170       *os << {\cf22 "\\\\r"};\par
171       {\cf19 break};\par
172     {\cf19 case} L{\cf23 '\\t'}:\par
173       *os << {\cf22 "\\\\t"};\par
174       {\cf19 break};\par
175     {\cf19 case} L{\cf23 '\\v'}:\par
176       *os << {\cf22 "\\\\v"};\par
177       {\cf19 break};\par
178     {\cf19 default}:\par
179       {\cf19 if} (IsPrintableAscii(c)) \{\par
180         *os << static_cast<char>(c);\par
181         {\cf19 return} kAsIs;\par
182       \} {\cf19 else} \{\par
183         *os << {\cf22 "\\\\x"} + String::FormatHexInt({\cf17 static_cast<}UnsignedChar{\cf17 >}(c));\par
184         {\cf19 return} kHexEscape;\par
185       \}\par
186   \}\par
187   {\cf19 return} kSpecialEscape;\par
188 \}\par
}
{
\ql
References testing::internal::String::FormatHexInt(), IsPrintableAscii(), kAsIs, kHexEscape, and kSpecialEscape.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab73d250fde6dfbf16111afb7a071dc3f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintAsStringLiteralTo\:testing::internal}
{\xe \v testing::internal\:PrintAsStringLiteralTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b CharFormat} testing::internal::PrintAsStringLiteralTo (char  {\i c}, ostream *  {\i os}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 207                                                               \{\par
208   {\cf19 return} PrintAsStringLiteralTo(\par
209       {\cf17 static_cast<}{\cf18 wchar_t}{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)), os);\par
210 \}\par
}
{
\ql
References PrintAsStringLiteralTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a82e5b3cf45fd9c4603dbe14bc4cb38c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintAsStringLiteralTo\:testing::internal}
{\xe \v testing::internal\:PrintAsStringLiteralTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b CharFormat} testing::internal::PrintAsStringLiteralTo (wchar_t  {\i c}, ostream *  {\i os}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 192                                                                  \{\par
193   {\cf19 switch} (c) \{\par
194     {\cf19 case} L{\cf23 '\\''}:\par
195       *os << {\cf22 "'"};\par
196       {\cf19 return} kAsIs;\par
197     {\cf19 case} L{\cf23 '"'}:\par
198       *os << {\cf22 "\\\\\\""};\par
199       {\cf19 return} kSpecialEscape;\par
200     {\cf19 default}:\par
201       {\cf19 return} PrintAsCharLiteralTo<wchar_t>(c, os);\par
202   \}\par
203 \}\par
}
{
\ql
References kAsIs, and kSpecialEscape.}\par
{
\ql
Referenced by PrintAsStringLiteralTo(), and PrintCharsAsStringTo().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a8c5838995d7bb9e4232b69e6bcdb9ab8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintCharAndCodeTo\:testing::internal}
{\xe \v testing::internal\:PrintCharAndCodeTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UnsignedChar , typename Char > void testing::internal::PrintCharAndCodeTo (Char  {\i c}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 217                                              \{\par
218   {\cf20 // First, print c as a literal in the most readable form we can find.}\par
219   *os << (({\cf17 sizeof}(c) > 1) ? {\cf22 "L'"} : {\cf22 "'"});\par
220   {\cf17 const} CharFormat format = PrintAsCharLiteralTo<UnsignedChar>(c, os);\par
221   *os << {\cf22 "'"};\par
222 \par
223   {\cf20 // To aid user debugging, we also print c's code in decimal, unless}\par
224   {\cf20 // it's 0 (in which case c was printed as '\\\\0', making the code}\par
225   {\cf20 // obvious).}\par
226   {\cf19 if} (c == 0)\par
227     {\cf19 return};\par
228   *os << {\cf22 " ("} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c);\par
229 \par
230   {\cf20 // For more convenience, we print c's code again in hexidecimal,}\par
231   {\cf20 // unless c was already printed in the form '\\x##' or the code is in}\par
232   {\cf20 // [1, 9].}\par
233   {\cf19 if} (format == kHexEscape || (1 <= c && c <= 9)) \{\par
234     {\cf20 // Do nothing.}\par
235   \} {\cf19 else} \{\par
236     *os << {\cf22 ", 0x"} << String::FormatHexInt({\cf17 static_cast<}UnsignedChar{\cf17 >}(c));\par
237   \}\par
238   *os << {\cf22 ")"};\par
239 \}\par
}
{
\ql
References testing::internal::String::FormatHexInt(), and kHexEscape.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0c577e598e61d339ba45dd6643fb1969_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintCharsAsStringTo\:testing::internal}
{\xe \v testing::internal\:PrintCharsAsStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_} {\b GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_} static {\b GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_} void testing::internal::PrintCharsAsStringTo (const CharType *  {\i begin}, size_t  {\i len}, ostream *  {\i os}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 263                                                     \{\par
264   {\cf17 const} {\cf18 char}* {\cf17 const} kQuoteBegin = {\cf17 sizeof}(CharType) == 1 ? {\cf22 "\\""} : {\cf22 "L\\""};\par
265   *os << kQuoteBegin;\par
266   {\cf18 bool} is_previous_hex = {\cf17 false};\par
267   {\cf19 for} ({\cf18 size_t} index = 0; index < len; ++index) \{\par
268     {\cf17 const} CharType cur = begin[index];\par
269     {\cf19 if} (is_previous_hex && IsXDigit(cur)) \{\par
270       {\cf20 // Previous character is of '\\x..' form and this character can be}\par
271       {\cf20 // interpreted as another hexadecimal digit in its number. Break string to}\par
272       {\cf20 // disambiguate.}\par
273       *os << {\cf22 "\\" "} << kQuoteBegin;\par
274     \}\par
275     is_previous_hex = PrintAsStringLiteralTo(cur, os) == kHexEscape;\par
276   \}\par
277   *os << {\cf22 "\\""};\par
278 \}\par
}
{
\ql
References IsXDigit(), kHexEscape, and PrintAsStringLiteralTo().}\par
{
\ql
Referenced by PrintStringTo(), PrintTo(), and UniversalPrintCharArray().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0be71e6d7cb274131c559193f81c83e2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0be71e6d7cb274131c559193f81c83e2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintColorEncoded\:testing::internal}
{\xe \v testing::internal\:PrintColorEncoded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::PrintColorEncoded (const char *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5125                                                \{\par
5126   GTestColor color = COLOR_DEFAULT;  {\cf20 // The current color.}\par
5127 \par
5128   {\cf20 // Conceptually, we split the string into segments divided by escape}\par
5129   {\cf20 // sequences.  Then we print one segment at a time.  At the end of}\par
5130   {\cf20 // each iteration, the str pointer advances to the beginning of the}\par
5131   {\cf20 // next segment.}\par
5132   {\cf19 for} (;;) \{\par
5133     {\cf17 const} {\cf18 char}* p = strchr(str, {\cf23 '@'});\par
5134     {\cf19 if} (p == NULL) \{\par
5135       ColoredPrintf(color, {\cf22 "%s"}, str);\par
5136       {\cf19 return};\par
5137     \}\par
5138 \par
5139     ColoredPrintf(color, {\cf22 "%s"}, std::string(str, p).c_str());\par
5140 \par
5141     {\cf17 const} {\cf18 char} ch = p[1];\par
5142     str = p + 2;\par
5143     {\cf19 if} (ch == {\cf23 '@'}) \{\par
5144       ColoredPrintf(color, {\cf22 "@"});\par
5145     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'D'}) \{\par
5146       color = COLOR_DEFAULT;\par
5147     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'R'}) \{\par
5148       color = COLOR_RED;\par
5149     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'G'}) \{\par
5150       color = COLOR_GREEN;\par
5151     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'Y'}) \{\par
5152       color = COLOR_YELLOW;\par
5153     \} {\cf19 else} \{\par
5154       --str;\par
5155     \}\par
5156   \}\par
5157 \}\par
}
{
\ql
References COLOR_DEFAULT, COLOR_GREEN, COLOR_RED, COLOR_YELLOW, and ColoredPrintf().}\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7d8c446a29c7e22d7d4dde8f530bb57e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7d8c446a29c7e22d7d4dde8f530bb57e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintFullTestCommentIfPresent\:testing::internal}
{\xe \v testing::internal\:PrintFullTestCommentIfPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintFullTestCommentIfPresent (const {\b TestInfo} &  {\i test_info})}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3009                                                               \{\par
3010   {\cf17 const} {\cf18 char}* {\cf17 const} type_param = test_info.type_param();\par
3011   {\cf17 const} {\cf18 char}* {\cf17 const} value_param = test_info.value_param();\par
3012 \par
3013   {\cf19 if} (type_param != NULL || value_param != NULL) \{\par
3014     printf({\cf22 ", where "});\par
3015     {\cf19 if} (type_param != NULL) \{\par
3016       printf({\cf22 "%s = %s"}, kTypeParamLabel, type_param);\par
3017       {\cf19 if} (value_param != NULL)\par
3018         printf({\cf22 " and "});\par
3019     \}\par
3020     {\cf19 if} (value_param != NULL) \{\par
3021       printf({\cf22 "%s = %s"}, kValueParamLabel, value_param);\par
3022     \}\par
3023   \}\par
3024 \}\par
}
{
\ql
References kTypeParamLabel, kValueParamLabel, testing::TestInfo::type_param, and testing::TestInfo::value_param.}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnTestEnd(), and testing::internal::PrettyUnitTestResultPrinter::PrintFailedTests().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7a85ebe3b4de93a1edb091f92f1fb393_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintOnOneLine\:testing::internal}
{\xe \v testing::internal\:PrintOnOneLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::PrintOnOneLine (const char *  {\i str}, int  {\i max_length}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4846                                                             \{\par
4847   {\cf19 if} (str != NULL) \{\par
4848     {\cf19 for} ({\cf18 int} i = 0; *str != {\cf23 '\\0'}; ++str) \{\par
4849       {\cf19 if} (i >= max_length) \{\par
4850         printf({\cf22 "..."});\par
4851         {\cf19 break};\par
4852       \}\par
4853       {\cf19 if} (*str == {\cf23 '\\n'}) \{\par
4854         printf({\cf22 "\\\\n"});\par
4855         i += 2;\par
4856       \} {\cf19 else} \{\par
4857         printf({\cf22 "%c"}, *str);\par
4858         ++i;\par
4859       \}\par
4860     \}\par
4861   \}\par
4862 \}\par
}
{
\ql
Referenced by testing::internal::UnitTestImpl::ListTestsMatchingFilter().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a4a8708bfb808411f9d918c7356ae7362_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintRawArrayTo\:testing::internal}
{\xe \v testing::internal\:PrintRawArrayTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::PrintRawArrayTo (const T  {\i a}[], size_t  {\i count}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 548                                                                 \{\par
549   UniversalPrint(a[0], os);\par
550   {\cf19 for} ({\cf18 size_t} i = 1; i != count; i++) \{\par
551     *os << {\cf22 ", "};\par
552     UniversalPrint(a[i], os);\par
553   \}\par
554 \}\par
}
{
\ql
References UniversalPrint().}\par
{
\ql
Referenced by UniversalPrintArray().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad3013b6b4c825edee9fe18ff1d982faa_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintStringTo\:testing::internal}
{\xe \v testing::internal\:PrintStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintStringTo (const ::{\b std::string} &  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintStringTo\:testing::internal}
{\xe \v testing::internal\:PrintStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintStringTo (const ::{\b std::string} &  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 354                                                     \{\par
355   PrintCharsAsStringTo(s.data(), s.size(), os);\par
356 \}\par
}
{
\ql
References PrintCharsAsStringTo().}\par
{
\ql
Referenced by PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad609167d8d6792b0fb186539e0e159bd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad609167d8d6792b0fb186539e0e159bd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTestPartResult\:testing::internal}
{\xe \v testing::internal\:PrintTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::PrintTestPartResult (const {\b TestPartResult} &  {\i test_part_result}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2860                                                                         \{\par
2861   {\cf17 const} std::string& result =\par
2862       PrintTestPartResultToString(test_part_result);\par
2863   printf({\cf22 "%s\\n"}, result.c_str());\par
2864   fflush(stdout);\par
2865   {\cf20 // If the test program runs in Visual Studio or a debugger, the}\par
2866   {\cf20 // following statements add the test part result message to the Output}\par
2867   {\cf20 // window such that the user can double-click on it to jump to the}\par
2868   {\cf20 // corresponding source code location; otherwise they do nothing.}\par
2869 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
2870   {\cf20 // We don't call OutputDebugString*() on Windows Mobile, as printing}\par
2871   {\cf20 // to stdout is done by OutputDebugString() there already - we don't}\par
2872   {\cf20 // want the same message printed twice.}\par
2873   ::OutputDebugStringA(result.c_str());\par
2874   ::OutputDebugStringA({\cf22 "\\n"});\par
2875 {\cf21 #endif}\par
2876 \}\par
}
{
\ql
References std::string::c_str(), and PrintTestPartResultToString().}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnTestPartResult().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac844b3d05dd6f665f72e2a1cec1872ba_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac844b3d05dd6f665f72e2a1cec1872ba_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTestPartResultToString\:testing::internal}
{\xe \v testing::internal\:PrintTestPartResultToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b std::string} testing::internal::PrintTestPartResultToString (const {\b TestPartResult} &  {\i test_part_result}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2851                                             \{\par
2852   {\cf19 return} (Message()\par
2853           << internal::FormatFileLocation(test_part_result.file_name(),\par
2854                                           test_part_result.line_number())\par
2855           << {\cf22 " "} << TestPartResultTypeToString(test_part_result.type())\par
2856           << test_part_result.message()).GetString();\par
2857 \}\par
}
{
\ql
References testing::TestPartResult::file_name(), FormatFileLocation(), testing::TestPartResult::line_number(), testing::TestPartResult::message(), testing::TestPartResultTypeToString(), and testing::TestPartResult::type().}\par
{
\ql
Referenced by PrintTestPartResult().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ada13cbf91139f0809a5a31ea2594c1ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ada13cbf91139f0809a5a31ea2594c1ad_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (bool  {\i x}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 495                                             \{\par
496   *os << (x ? {\cf22 "true"} : {\cf22 "false"});\par
497 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 510                                              \{\par
511   PrintTo(ImplicitCast_<const char*>(s), os);\par
512 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a553eec7bb50de01c9e91cac4accc606f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (char  {\i c}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 487                                             \{\par
488   {\cf20 // When printing a plain char, we always treat it as unsigned.  This}\par
489   {\cf20 // way, the output won't be affected by whether the compiler thinks}\par
490   {\cf20 // char is signed or not.}\par
491   PrintTo({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c), os);\par
492 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a476bd3d411d4f129620aaf8999c257c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > void testing::internal::PrintTo (const ::{\b std::pair}< T1, T2 > &  {\i value}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 676                                                            \{\par
677   *os << {\cf23 '('};\par
678   {\cf20 // We cannot use UniversalPrint(value.first, os) here, as T1 may be}\par
679   {\cf20 // a reference type.  The same for printing value.second.}\par
680   UniversalPrinter<T1>::Print(value.first, os);\par
681   *os << {\cf22 ", "};\par
682   UniversalPrinter<T2>::Print(value.second, os);\par
683   *os << {\cf23 ')'};\par
684 \}\par
}
{
\ql
References testing::internal::UniversalPrinter< T >::Print().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af2c33928facbf2edf7af564278724d98_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const ::{\b std::string} &  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 565                                                         \{\par
566   PrintStringTo(s, os);\par
567 \}\par
}
{
\ql
References PrintStringTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_af59b4f5d83276cd807c45063b14bad44_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (const char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const char *  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 320                                          \{\par
321   {\cf19 if} (s == NULL) \{\par
322     *os << {\cf22 "NULL"};\par
323   \} {\cf19 else} \{\par
324     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
325     PrintCharsAsStringTo(s, strlen(s), os);\par
326   \}\par
327 \}\par
}
{
\ql
References PrintCharsAsStringTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_adc6c98306d40b53fd07be4e295102a0a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const signed char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 516                                                           \{\par
517   PrintTo(ImplicitCast_<const void*>(s), os);\par
518 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a792cc5665a34619ed7a6d54711433456_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::PrintTo (const T &  {\i value}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 454                                              \{\par
455   {\cf20 // DefaultPrintTo() is overloaded.  The type of its first two}\par
456   {\cf20 // arguments determine which version will be picked.  If T is an}\par
457   {\cf20 // STL-style container, the version for container will be called; if}\par
458   {\cf20 // T is a pointer, the pointer version will be called; otherwise the}\par
459   {\cf20 // generic version will be called.}\par
460   {\cf20 //}\par
461   {\cf20 // Note that we check for container types here, prior to we check}\par
462   {\cf20 // for protocol message types in our operator<<.  The rationale is:}\par
463   {\cf20 //}\par
464   {\cf20 // For protocol messages, we want to give people a chance to}\par
465   {\cf20 // override Google Mock's format by defining a PrintTo() or}\par
466   {\cf20 // operator<<.  For STL containers, other formats can be}\par
467   {\cf20 // incompatible with Google Mock's format for the container}\par
468   {\cf20 // elements; therefore we check for container types here to ensure}\par
469   {\cf20 // that our format is used.}\par
470   {\cf20 //}\par
471   {\cf20 // The second argument of DefaultPrintTo() is needed to bypass a bug}\par
472   {\cf20 // in Symbian's C++ compiler that prevents it from picking the right}\par
473   {\cf20 // overload between:}\par
474   {\cf20 //}\par
475   {\cf20 //   PrintTo(const T& x, ...);}\par
476   {\cf20 //   PrintTo(T* x, ...);}\par
477   DefaultPrintTo(IsContainerTest<T>(0), is_pointer<T>(), value, os);\par
478 \}\par
}
{
\ql
References DefaultPrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_adb3c27150dbe661db0e0c4be27533460_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const unsigned char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 522                                                             \{\par
523   PrintTo(ImplicitCast_<const void*>(s), os);\par
524 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a42c591f2164ad105b502a9262333aed2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (const wchar_t *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const wchar_t *  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 337                                             \{\par
338   {\cf19 if} (s == NULL) \{\par
339     *os << {\cf22 "NULL"};\par
340   \} {\cf19 else} \{\par
341     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
342     PrintCharsAsStringTo(s, std::wcslen(s), os);\par
343   \}\par
344 \}\par
}
{
\ql
References PrintCharsAsStringTo(), and std::wcslen().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_afc20fb56b2547a8f91f9ff99650f2024_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (signed char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 519                                                     \{\par
520   PrintTo(ImplicitCast_<const void*>(s), os);\par
521 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a1320096b116f8cc4b688acbd5b783051_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (signed char  {\i c}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 244                                             \{\par
245   PrintCharAndCodeTo<unsigned char>(c, os);\par
246 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (unsigned char *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 525                                                       \{\par
526   PrintTo(ImplicitCast_<const void*>(s), os);\par
527 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a7fae797c500d66d0f5a9db4f205e3416_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (unsigned char  {\i c}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 241                                               \{\par
242   PrintCharAndCodeTo<unsigned char>(c, os);\par
243 \}\par
}
{
\ql
Referenced by testing::internal::UniversalPrinter< T >::Print(), and PrintTo().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa7e70a85d66f0c109e3e69629ef577f2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (wchar_t *  {\i s}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 537                                                 \{\par
538   PrintTo(ImplicitCast_<const wchar_t*>(s), os);\par
539 \}\par
}
{
\ql
References PrintTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a8d41baa371fad3eb5a3dbe1bbc02c290_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (wchar_t  {\i wc}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (wchar_t  {\i wc}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 250                                       \{\par
251   PrintCharAndCodeTo<wchar_t>(wc, os);\par
252 \}\par
}
}
{\xe \v ReadEntireFile\:testing::internal}
{\xe \v testing::internal\:ReadEntireFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::ReadEntireFile (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1081                                      \{\par
1082   {\cf17 const} {\cf18 size_t} file_size = GetFileSize(file);\par
1083   {\cf18 char}* {\cf17 const} buffer = {\cf17 new} {\cf18 char}[file_size];\par
1084 \par
1085   {\cf18 size_t} bytes_last_read = 0;  {\cf20 // # of bytes read in the last fread()}\par
1086   {\cf18 size_t} bytes_read = 0;       {\cf20 // # of bytes read so far}\par
1087 \par
1088   fseek(file, 0, SEEK_SET);\par
1089 \par
1090   {\cf20 // Keeps reading the file until we cannot read further or the}\par
1091   {\cf20 // pre-determined file size is reached.}\par
1092   {\cf19 do} \{\par
1093     bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);\par
1094     bytes_read += bytes_last_read;\par
1095   \} {\cf19 while} (bytes_last_read > 0 && bytes_read < file_size);\par
1096 \par
1097   {\cf17 const} std::string content(buffer, bytes_read);\par
1098   {\cf17 delete}[] buffer;\par
1099 \par
1100   {\cf19 return} content;\par
1101 \}\par
}
{
\ql
References GetFileSize().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab81b0af2a0131ea54dc11de00d5e6e51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ReportFailureInUnknownLocation\:testing::internal}
{\xe \v testing::internal\:ReportFailureInUnknownLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ReportFailureInUnknownLocation ({\b TestPartResult::Type}  {\i result_type}, const {\b std::string} &  {\i message})}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2251                                                               \{\par
2252   {\cf20 // This function is a friend of UnitTest and as such has access to}\par
2253   {\cf20 // AddTestPartResult.}\par
2254   UnitTest::GetInstance()->AddTestPartResult(\par
2255       result_type,\par
2256       NULL,  {\cf20 // No info about the source file where the exception occurred.}\par
2257       -1,    {\cf20 // We have no info on which line caused the exception.}\par
2258       message,\par
2259       {\cf22 ""});   {\cf20 // No stack trace, either.}\par
2260 \}\par
}
{
\ql
References testing::UnitTest::AddTestPartResult(), and testing::UnitTest::GetInstance().}\par
{
\ql
Referenced by HandleExceptionsInMethodIfSupported(), and HandleSehExceptionsInMethodIfSupported().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a85f6ff0e40f9a5f10af66a73cf1364fa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a85f6ff0e40f9a5f10af66a73cf1364fa_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v SetUpEnvironment\:testing::internal}
{\xe \v testing::internal\:SetUpEnvironment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::SetUpEnvironment ({\b Environment} *  {\i env}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4539 \{ env->SetUp(); \}\par
}
{
\ql
References testing::Environment::SetUp().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5f5535012d4548788a5d1a4e0f18e19e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a5f5535012d4548788a5d1a4e0f18e19e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ShouldRunTestCase\:testing::internal}
{\xe \v testing::internal\:ShouldRunTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::ShouldRunTestCase (const {\b TestCase} *  {\i test_case}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 356                                                          \{\par
357   {\cf19 return} test_case->should_run();\par
358 \}\par
}
{
\ql
References testing::TestCase::should_run().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::test_case_to_run_count().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a73e562dfef3eb7b30dfbb7b5e88e6df2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a73e562dfef3eb7b30dfbb7b5e88e6df2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ShouldRunTestOnShard\:testing::internal}
{\xe \v testing::internal\:ShouldRunTestOnShard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldRunTestOnShard (int  {\i total_shards}, int  {\i shard_index}, int  {\i test_id})}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4778                                                                           \{\par
4779   {\cf19 return} (test_id % total_shards) == shard_index;\par
4780 \}\par
}
{
\ql
Referenced by testing::internal::UnitTestImpl::FilterTests().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a437bd89f5bc532778d7467600e210395_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ShouldShard\:testing::internal}
{\xe \v testing::internal\:ShouldShard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldShard (const char *  {\i total_shards_str}, const char *  {\i shard_index_str}, bool  {\i in_subprocess_for_death_test})}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4717                                                     \{\par
4718   {\cf19 if} (in_subprocess_for_death_test) \{\par
4719     {\cf19 return} {\cf17 false};\par
4720   \}\par
4721 \par
4722   {\cf17 const} Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);\par
4723   {\cf17 const} Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);\par
4724 \par
4725   {\cf19 if} (total_shards == -1 && shard_index == -1) \{\par
4726     {\cf19 return} {\cf17 false};\par
4727   \} {\cf19 else} {\cf19 if} (total_shards == -1 && shard_index != -1) \{\par
4728     {\cf17 const} Message msg = Message()\par
4729       << {\cf22 "Invalid environment variables: you have "}\par
4730       << kTestShardIndex << {\cf22 " = "} << shard_index\par
4731       << {\cf22 ", but have left "} << kTestTotalShards << {\cf22 " unset.\\n"};\par
4732     ColoredPrintf(COLOR_RED, msg.GetString().c_str());\par
4733     fflush(stdout);\par
4734     exit(EXIT_FAILURE);\par
4735   \} {\cf19 else} {\cf19 if} (total_shards != -1 && shard_index == -1) \{\par
4736     {\cf17 const} Message msg = Message()\par
4737       << {\cf22 "Invalid environment variables: you have "}\par
4738       << kTestTotalShards << {\cf22 " = "} << total_shards\par
4739       << {\cf22 ", but have left "} << kTestShardIndex << {\cf22 " unset.\\n"};\par
4740     ColoredPrintf(COLOR_RED, msg.GetString().c_str());\par
4741     fflush(stdout);\par
4742     exit(EXIT_FAILURE);\par
4743   \} {\cf19 else} {\cf19 if} (shard_index < 0 || shard_index >= total_shards) \{\par
4744     {\cf17 const} Message msg = Message()\par
4745       << {\cf22 "Invalid environment variables: we require 0 <= "}\par
4746       << kTestShardIndex << {\cf22 " < "} << kTestTotalShards\par
4747       << {\cf22 ", but you have "} << kTestShardIndex << {\cf22 "="} << shard_index\par
4748       << {\cf22 ", "} << kTestTotalShards << {\cf22 "="} << total_shards << {\cf22 ".\\n"};\par
4749     ColoredPrintf(COLOR_RED, msg.GetString().c_str());\par
4750     fflush(stdout);\par
4751     exit(EXIT_FAILURE);\par
4752   \}\par
4753 \par
4754   {\cf19 return} total_shards > 1;\par
4755 \}\par
}
{
\ql
References std::string::c_str(), COLOR_RED, ColoredPrintf(), testing::Message::GetString(), Int32FromEnvOrDie(), testing::kTestShardIndex, and testing::kTestTotalShards.}\par
{
\ql
Referenced by testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(), and testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0fe41657b1d1ab7ec4e37ec07403ee6c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0fe41657b1d1ab7ec4e37ec07403ee6c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ShouldUseColor\:testing::internal}
{\xe \v testing::internal\:ShouldUseColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldUseColor (bool  {\i stdout_is_tty})}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2916                                         \{\par
2917   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_color = GTEST_FLAG(color).c_str();\par
2918 \par
2919   {\cf19 if} (String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "auto"})) \{\par
2920 {\cf21 #if GTEST_OS_WINDOWS}\par
2921     {\cf20 // On Windows the TERM variable is usually not set, but the}\par
2922     {\cf20 // console there does support colors.}\par
2923     {\cf19 return} stdout_is_tty;\par
2924 {\cf21 #else}\par
2925     {\cf20 // On non-Windows platforms, we rely on the TERM variable.}\par
2926     {\cf17 const} {\cf18 char}* {\cf17 const} term = posix::GetEnv({\cf22 "TERM"});\par
2927     {\cf17 const} {\cf18 bool} term_supports_color =\par
2928         String::CStringEquals(term, {\cf22 "xterm"}) ||\par
2929         String::CStringEquals(term, {\cf22 "xterm-color"}) ||\par
2930         String::CStringEquals(term, {\cf22 "xterm-256color"}) ||\par
2931         String::CStringEquals(term, {\cf22 "screen"}) ||\par
2932         String::CStringEquals(term, {\cf22 "screen-256color"}) ||\par
2933         String::CStringEquals(term, {\cf22 "tmux"}) ||\par
2934         String::CStringEquals(term, {\cf22 "tmux-256color"}) ||\par
2935         String::CStringEquals(term, {\cf22 "rxvt-unicode"}) ||\par
2936         String::CStringEquals(term, {\cf22 "rxvt-unicode-256color"}) ||\par
2937         String::CStringEquals(term, {\cf22 "linux"}) ||\par
2938         String::CStringEquals(term, {\cf22 "cygwin"});\par
2939     {\cf19 return} stdout_is_tty && term_supports_color;\par
2940 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
2941   \}\par
2942 \par
2943   {\cf19 return} String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "yes"}) ||\par
2944       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "true"}) ||\par
2945       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "t"}) ||\par
2946       String::CStringEquals(gtest_color, {\cf22 "1"});\par
2947   {\cf20 // We take "yes", "true", "t", and "1" as meaning "yes".  If the}\par
2948   {\cf20 // value is neither one of these nor "auto", we treat it as "no" to}\par
2949   {\cf20 // be conservative.}\par
2950 \}\par
}
{
\ql
References testing::internal::String::CaseInsensitiveCStringEquals(), testing::internal::String::CStringEquals(), testing::internal::posix::GetEnv(), and GTEST_FLAG.}\par
{
\ql
Referenced by ColoredPrintf().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac1db1b4603967a6c4404f31cbbac31a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac1db1b4603967a6c4404f31cbbac31a6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Shuffle\:testing::internal}
{\xe \v testing::internal\:Shuffle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > void testing::internal::Shuffle ({\b internal::Random} *  {\i random}, {\b std::vector}< E > *  {\i v})}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 333                                                              \{\par
334   ShuffleRange(random, 0, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size()), v);\par
335 \}\par
}
{
\ql
References ShuffleRange(), and std::vector< T >::size().}\par
{
\ql
Referenced by testing::TestCase::ShuffleTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a90d9e6ffe8522a7eb1b2ce9b1a0c4673_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a90d9e6ffe8522a7eb1b2ce9b1a0c4673_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ShuffleRange\:testing::internal}
{\xe \v testing::internal\:ShuffleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > void testing::internal::ShuffleRange ({\b internal::Random} *  {\i random}, int  {\i begin}, int  {\i end}, {\b std::vector}< E > *  {\i v})}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 313                                    \{\par
314   {\cf17 const} {\cf18 int} size = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size());\par
315   GTEST_CHECK_(0 <= begin && begin <= size)\par
316       << {\cf22 "Invalid shuffle range start "} << begin << {\cf22 ": must be in range [0, "}\par
317       << size << {\cf22 "]."};\par
318   GTEST_CHECK_(begin <= end && end <= size)\par
319       << {\cf22 "Invalid shuffle range finish "} << end << {\cf22 ": must be in range ["}\par
320       << begin << {\cf22 ", "} << size << {\cf22 "]."};\par
321 \par
322   {\cf20 // Fisher-Yates shuffle, from}\par
323   {\cf20 // http://en.wikipedia.org/wiki/Fisher-Yates_shuffle}\par
324   {\cf19 for} ({\cf18 int} range_width = end - begin; range_width >= 2; range_width--) \{\par
325     {\cf17 const} {\cf18 int} last_in_range = begin + range_width - 1;\par
326     {\cf17 const} {\cf18 int} selected = begin + random->Generate(range_width);\par
327     std::swap((*v)[selected], (*v)[last_in_range]);\par
328   \}\par
329 \}\par
}
{
\ql
References testing::internal::Random::Generate(), GTEST_CHECK_, std::vector< T >::size(), and std::swap().}\par
{
\ql
Referenced by Shuffle(), and testing::internal::UnitTestImpl::ShuffleTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0e1d3dc36138a591769412d4c7779861_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a0e1d3dc36138a591769412d4c7779861_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v SkipPrefix\:testing::internal}
{\xe \v testing::internal\:SkipPrefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} bool testing::internal::SkipPrefix (const char *  {\i prefix}, const char **  {\i pstr})}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5001                                                        \{\par
5002   {\cf17 const} {\cf18 size_t} prefix_len = strlen(prefix);\par
5003   {\cf19 if} (strncmp(*pstr, prefix, prefix_len) == 0) \{\par
5004     *pstr += prefix_len;\par
5005     {\cf19 return} {\cf17 true};\par
5006   \}\par
5007   {\cf19 return} {\cf17 false};\par
5008 \}\par
}
{
\ql
Referenced by HasGoogleTestFlagPrefix().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aac72b20299ad4a99554ce161e1769560_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v SplitString\:testing::internal}
{\xe \v testing::internal\:SplitString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::SplitString (const ::{\b std::string} &  {\i str}, char  {\i delimiter}, ::{\b std::vector}< ::{\b std::string} > *  {\i dest})}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 923                                               \{\par
924   ::std::vector< ::std::string> parsed;\par
925   ::std::string::size_type pos = 0;\par
926   {\cf19 while} (::testing::internal::AlwaysTrue()) \{\par
927     const ::std::string::size_type colon = str.find(delimiter, pos);\par
928     {\cf19 if} (colon == ::std::string::npos) \{\par
929       parsed.push_back(str.substr(pos));\par
930       {\cf19 break};\par
931     \} {\cf19 else} \{\par
932       parsed.push_back(str.substr(pos, colon - pos));\par
933       pos = colon + 1;\par
934     \}\par
935   \}\par
936   dest->swap(parsed);\par
937 \}\par
}
{
\ql
References AlwaysTrue(), std::vector< T >::push_back(), and std::vector< T >::swap().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a8eb8eddf760375a490e007b20777ec56_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v StreamableToString\:testing::internal}
{\xe \v testing::internal\:StreamableToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b std::string} testing::internal::StreamableToString (const T &  {\i streamable})}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 243                                                   \{\par
244   {\cf19 return} (Message() << streamable).GetString();\par
245 \}\par
}
{
\ql
Referenced by FormatCompilerIndependentFileLocation(), testing::FormatCountableNoun(), FormatEpochTimeInMillisAsIso8601(), FormatFileLocation(), InitGoogleTestImpl(), testing::internal::FilePath::MakeFileName(), testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd(), testing::internal::PrettyUnitTestResultPrinter::OnTestEnd(), testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(), ParseGoogleTestFlagsOnlyImpl(), testing::internal::XmlUnitTestResultPrinter::PrintXmlTestCase(), and testing::internal::XmlUnitTestResultPrinter::PrintXmlUnitTest().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aad4beed95d0846e6ffc5da0978ef3bb9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v StringFromGTestEnv\:testing::internal}
{\xe \v testing::internal\:StringFromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::StringFromGTestEnv (const char *  {\i flag}, const char *  {\i default_value})}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1229                                                                           \{\par
1230 {\cf21 #if defined(GTEST_GET_STRING_FROM_ENV_)}\par
1231   {\cf19 return} GTEST_GET_STRING_FROM_ENV_(flag, default_value);\par
1232 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_STRING_FROM_ENV_)}\par
1233   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
1234   {\cf17 const} {\cf18 char}* value = posix::GetEnv(env_var.c_str());\par
1235   {\cf19 if} (value != NULL) \{\par
1236     {\cf19 return} value;\par
1237   \}\par
1238 \par
1239   {\cf20 // As a special case for the 'output' flag, if GTEST_OUTPUT is not}\par
1240   {\cf20 // set, we look for XML_OUTPUT_FILE, which is set by the Bazel build}\par
1241   {\cf20 // system.  The value of XML_OUTPUT_FILE is a filename without the}\par
1242   {\cf20 // "xml:" prefix of GTEST_OUTPUT.}\par
1243   {\cf20 //}\par
1244   {\cf20 // The net priority order after flag processing is thus:}\par
1245   {\cf20 //   --gtest_output command line flag}\par
1246   {\cf20 //   GTEST_OUTPUT environment variable}\par
1247   {\cf20 //   XML_OUTPUT_FILE environment variable}\par
1248   {\cf20 //   'default_value'}\par
1249   {\cf19 if} (strcmp(flag, {\cf22 "output"}) == 0) \{\par
1250     value = posix::GetEnv({\cf22 "XML_OUTPUT_FILE"});\par
1251     {\cf19 if} (value != NULL) \{\par
1252       {\cf19 return} std::string({\cf22 "xml:"}) + value;\par
1253     \}\par
1254   \}\par
1255   {\cf19 return} default_value;\par
1256 \}\par
}
{
\ql
References std::string::c_str(), FlagToEnvVar(), and testing::internal::posix::GetEnv().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab38c435530c97f10fd7a8008a76331f2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v StringStreamToString\:testing::internal}
{\xe \v testing::internal\:StringStreamToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::StringStreamToString (::{\b std::stringstream} *  {\i ss})}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1982                                                     \{\par
1983   const ::std::string& str = ss->str();\par
1984   {\cf17 const} {\cf18 char}* {\cf17 const} start = str.c_str();\par
1985   {\cf17 const} {\cf18 char}* {\cf17 const} end = start + str.length();\par
1986 \par
1987   std::string result;\par
1988   result.reserve(2 * (end - start));\par
1989   {\cf19 for} ({\cf17 const} {\cf18 char}* ch = start; ch != end; ++ch) \{\par
1990     {\cf19 if} (*ch == {\cf23 '\\0'}) \{\par
1991       result += {\cf22 "\\\\0"};  {\cf20 // Replaces NUL with "\\\\0";}\par
1992     \} {\cf19 else} \{\par
1993       result += *ch;\par
1994     \}\par
1995   \}\par
1996 \par
1997   {\cf19 return} result;\par
1998 \}\par
}
{
\ql
References std::string::reserve(), and std::stringstream::str().}\par
{
\ql
Referenced by CmpHelperFloatingPointEQ(), FloatingPointLE(), testing::Message::GetString(), testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd(), and WideStringToUtf8().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab56e151d23ee7e14dbf03ac7aa1d182b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ab56e151d23ee7e14dbf03ac7aa1d182b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v StripTrailingSpaces\:testing::internal}
{\xe \v testing::internal\:StripTrailingSpaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::StripTrailingSpaces ({\b std::string}  {\i str})}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2284                                                     \{\par
2285   std::string::iterator it = str.end();\par
2286   {\cf19 while} (it != str.begin() && IsSpace(*--it))\par
2287     it = str.erase(it);\par
2288   {\cf19 return} str;\par
2289 \}\par
}
{
\ql
References std::string::begin(), std::string::end(), std::string::erase(), and IsSpace().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aa6afda12e567c353e2e9b9c2e8cae14f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v SumOverTestCaseList\:testing::internal}
{\xe \v testing::internal\:SumOverTestCaseList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int testing::internal::SumOverTestCaseList (const {\b std::vector}< {\b TestCase} * > &  {\i case_list}, int(TestCase::*)() const  {\i method}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 336                                                               \{\par
337   {\cf18 int} sum = 0;\par
338   {\cf19 for} ({\cf18 size_t} i = 0; i < case_list.size(); i++) \{\par
339     sum += (case_list[i]->*method)();\par
340   \}\par
341   {\cf19 return} sum;\par
342 \}\par
}
{
\ql
References std::vector< T >::size().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::disabled_test_count(), testing::internal::UnitTestImpl::failed_test_count(), testing::internal::UnitTestImpl::reportable_disabled_test_count(), testing::internal::UnitTestImpl::reportable_test_count(), testing::internal::UnitTestImpl::successful_test_count(), testing::internal::UnitTestImpl::test_to_run_count(), and testing::internal::UnitTestImpl::total_test_count().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad1b758141e7e064d00a2bf0355c8ee43_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad1b758141e7e064d00a2bf0355c8ee43_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TearDownEnvironment\:testing::internal}
{\xe \v testing::internal\:TearDownEnvironment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::TearDownEnvironment ({\b Environment} *  {\i env}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4540 \{ env->TearDown(); \}\par
}
{
\ql
References testing::Environment::TearDown().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac467e871e4781da3f5ebed2a4465aec4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac467e871e4781da3f5ebed2a4465aec4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TempDir\:testing::internal}
{\xe \v testing::internal\:TempDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} {\b std::string} testing::internal::TempDir ()}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1058                     \{\par
1059 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
1060   {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
1061 {\cf21 #elif GTEST_OS_WINDOWS}\par
1062   {\cf17 const} {\cf18 char}* temp_dir = posix::GetEnv({\cf22 "TEMP"});\par
1063   {\cf19 if} (temp_dir == NULL || temp_dir[0] == {\cf23 '\\0'})\par
1064     {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
1065   {\cf19 else} {\cf19 if} (temp_dir[strlen(temp_dir) - 1] == {\cf23 '\\\\'})\par
1066     {\cf19 return} temp_dir;\par
1067   {\cf19 else}\par
1068     {\cf19 return} std::string(temp_dir) + {\cf22 "\\\\"};\par
1069 {\cf21 #elif GTEST_OS_LINUX_ANDROID}\par
1070   {\cf19 return} {\cf22 "/sdcard/"};\par
1071 {\cf21 #else}\par
1072   {\cf19 return} {\cf22 "/tmp/"};\par
1073 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
1074 \}\par
}
{
\ql
References testing::internal::posix::GetEnv().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a9183d29a7f57e2906d03b644e6a12a4a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TestCaseFailed\:testing::internal}
{\xe \v testing::internal\:TestCaseFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::TestCaseFailed (const {\b TestCase} *  {\i test_case}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 350                                                       \{\par
351   {\cf19 return} test_case->should_run() && test_case->Failed();\par
352 \}\par
}
{
\ql
References testing::TestCase::Failed(), and testing::TestCase::should_run().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::failed_test_case_count().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a53454b6089c1c5b25319caa9de6c5c02_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a53454b6089c1c5b25319caa9de6c5c02_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v TestCasePassed\:testing::internal}
{\xe \v testing::internal\:TestCasePassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::TestCasePassed (const {\b TestCase} *  {\i test_case}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 345                                                       \{\par
346   {\cf19 return} test_case->should_run() && test_case->Passed();\par
347 \}\par
}
{
\ql
References testing::TestCase::Passed(), and testing::TestCase::should_run().}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::successful_test_case_count().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aadc7afca7aab40f7f1d41bc17974459a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_aadc7afca7aab40f7f1d41bc17974459a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ToLower\:testing::internal}
{\xe \v testing::internal\:ToLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::ToLower (char  {\i ch})}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2277                              \{\par
2278   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
2279 \}\par
}
}
{\xe \v ToUpper\:testing::internal}
{\xe \v testing::internal\:ToUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::ToUpper (char  {\i ch})}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2280                              \{\par
2281   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(toupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
2282 \}\par
}
{
\ql
Referenced by FlagToEnvVar().}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ac1b876a8133895bd553d4780ecaa1e3a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalPrint\:testing::internal}
{\xe \v testing::internal\:UniversalPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalPrint (const T &  {\i value}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 852                                                     \{\par
853   {\cf20 // A workarond for the bug in VC++ 7.1 that prevents us from instantiating}\par
854   {\cf20 // UniversalPrinter with T directly.}\par
855   {\cf17 typedef} T T1;\par
856   UniversalPrinter<T1>::Print(value, os);\par
857 \}\par
}
{
\ql
References testing::internal::UniversalPrinter< T >::Print().}\par
{
\ql
Referenced by DefaultPrintTo(), testing::internal::UniversalTersePrinter< const char * >::Print(), testing::internal::UniversalPrinter< T & >::Print(), testing::internal::UniversalTersePrinter< T >::Print(), testing::internal::UniversalTersePrinter< T & >::Print(), and PrintRawArrayTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a30708fa2bacf11895b03bdb21eb72309_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::UniversalPrintArray (const char *  {\i begin}, size_t  {\i len}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UniversalPrintArray (const char *  {\i begin}, size_t  {\i len}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 309                                                                      \{\par
310   UniversalPrintCharArray(begin, len, os);\par
311 \}\par
}
{
\ql
References UniversalPrintCharArray().}\par
{
\ql
Referenced by testing::internal::UniversalPrinter< T[N]>::Print().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a070107e7a8205ad6ec4d538d52b15b38_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a070107e7a8205ad6ec4d538d52b15b38_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalPrintArray (const T *  {\i begin}, size_t  {\i len}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 716                                                                      \{\par
717   {\cf19 if} (len == 0) \{\par
718     *os << {\cf22 "\{\}"};\par
719   \} {\cf19 else} \{\par
720     *os << {\cf22 "\{ "};\par
721     {\cf17 const} {\cf18 size_t} kThreshold = 18;\par
722     {\cf17 const} {\cf18 size_t} kChunkSize = 8;\par
723     {\cf20 // If the array has more than kThreshold elements, we'll have to}\par
724     {\cf20 // omit some details by printing only the first and the last}\par
725     {\cf20 // kChunkSize elements.}\par
726     {\cf20 // TODO(wan@google.com): let the user control the threshold using a flag.}\par
727     {\cf19 if} (len <= kThreshold) \{\par
728       PrintRawArrayTo(begin, len, os);\par
729     \} {\cf19 else} \{\par
730       PrintRawArrayTo(begin, kChunkSize, os);\par
731       *os << {\cf22 ", ..., "};\par
732       PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\par
733     \}\par
734     *os << {\cf22 " \}"};\par
735   \}\par
736 \}\par
}
{
\ql
References PrintRawArrayTo().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad79d71c3110f8eb24ab352d68f29436a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::UniversalPrintArray (const wchar_t *  {\i begin}, size_t  {\i len}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UniversalPrintArray (const wchar_t *  {\i begin}, size_t  {\i len}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 315                                                                         \{\par
316   UniversalPrintCharArray(begin, len, os);\par
317 \}\par
}
{
\ql
References UniversalPrintCharArray().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a52394019018eb5079f9f1bcca23dcd60_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalPrintCharArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintCharArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_} {\b GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_} static {\b GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_} void testing::internal::UniversalPrintCharArray (const CharType *  {\i begin}, size_t  {\i len}, ostream *  {\i os}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 287                                                     \{\par
288   {\cf20 // The code}\par
289   {\cf20 //   const char kFoo[] = "foo";}\par
290   {\cf20 // generates an array of 4, not 3, elements, with the last one being '\\0'.}\par
291   {\cf20 //}\par
292   {\cf20 // Therefore when printing a char array, we don't print the last element if}\par
293   {\cf20 // it's '\\0', such that the output matches the string literal as it's}\par
294   {\cf20 // written in the source code.}\par
295   {\cf19 if} (len > 0 && begin[len - 1] == {\cf23 '\\0'}) \{\par
296     PrintCharsAsStringTo(begin, len - 1, os);\par
297     {\cf19 return};\par
298   \}\par
299 \par
300   {\cf20 // If, however, the last element in the array is not '\\0', e.g.}\par
301   {\cf20 //    const char kFoo[] = \{ 'f', 'o', 'o' \};}\par
302   {\cf20 // we must print the entire array.  We also print a message to indicate}\par
303   {\cf20 // that the array is not NUL-terminated.}\par
304   PrintCharsAsStringTo(begin, len, os);\par
305   *os << {\cf22 " (no terminating NUL)"};\par
306 \}\par
}
{
\ql
References PrintCharsAsStringTo().}\par
{
\ql
Referenced by UniversalPrintArray().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad896a4e4d9133ce43dc18b6038d95dc3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_ad896a4e4d9133ce43dc18b6038d95dc3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UniversalTersePrint\:testing::internal}
{\xe \v testing::internal\:UniversalTersePrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalTersePrint (const T &  {\i value}, ::{\b std::ostream} *  {\i os})}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 843                                                          \{\par
844   UniversalTersePrinter<T>::Print(value, os);\par
845 \}\par
}
{
\ql
References testing::internal::UniversalTersePrinter< T >::Print().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_afa92f5a284929dc3723e654a25feb7b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WideStringToUtf8\:testing::internal}
{\xe \v testing::internal\:WideStringToUtf8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::string} testing::internal::WideStringToUtf8 (const wchar_t *  {\i str}, int  {\i num_chars})}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1823                                                               \{\par
1824   {\cf19 if} (num_chars == -1)\par
1825     num_chars = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(wcslen(str));\par
1826 \par
1827   ::std::stringstream stream;\par
1828   {\cf19 for} ({\cf18 int} i = 0; i < num_chars; ++i) \{\par
1829     UInt32 unicode_code_point;\par
1830 \par
1831     {\cf19 if} (str[i] == L{\cf23 '\\0'}) \{\par
1832       {\cf19 break};\par
1833     \} {\cf19 else} {\cf19 if} (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) \{\par
1834       unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],\par
1835                                                                  str[i + 1]);\par
1836       i++;\par
1837     \} {\cf19 else} \{\par
1838       unicode_code_point = {\cf17 static_cast<}UInt32{\cf17 >}(str[i]);\par
1839     \}\par
1840 \par
1841     stream << CodePointToUtf8(unicode_code_point);\par
1842   \}\par
1843   {\cf19 return} StringStreamToString(&stream);\par
1844 \}\par
}
{
\ql
References CodePointToUtf8(), CreateCodePointFromUtf16SurrogatePair(), IsUtf16SurrogatePair(), and StringStreamToString().}\par
{
\ql
Referenced by testing::internal::String::ShowWideCString().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a05b8c86ff38243f34d8f839a0eadefb1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a05b8c86ff38243f34d8f839a0eadefb1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v WriteToShardStatusFileIfNeeded\:testing::internal}
{\xe \v testing::internal\:WriteToShardStatusFileIfNeeded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::WriteToShardStatusFileIfNeeded ()}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4693                                       \{\par
4694   {\cf17 const} {\cf18 char}* {\cf17 const} test_shard_file = posix::GetEnv(kTestShardStatusFile);\par
4695   {\cf19 if} (test_shard_file != NULL) \{\par
4696     FILE* {\cf17 const} file = posix::FOpen(test_shard_file, {\cf22 "w"});\par
4697     {\cf19 if} (file == NULL) \{\par
4698       ColoredPrintf(COLOR_RED,\par
4699                     {\cf22 "Could not write to the test shard status file \\"%s\\" "}\par
4700                     {\cf22 "specified by the %s environment variable.\\n"},\par
4701                     test_shard_file, kTestShardStatusFile);\par
4702       fflush(stdout);\par
4703       exit(EXIT_FAILURE);\par
4704     \}\par
4705     fclose(file);\par
4706   \}\par
4707 \}\par
}
{
\ql
References COLOR_RED, ColoredPrintf(), testing::internal::posix::FOpen(), testing::internal::posix::GetEnv(), and testing::kTestShardStatusFile.}\par
{
\ql
Referenced by testing::internal::UnitTestImpl::RunAllTests().}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a19b35b39782d41e6ef76e1910a3a502e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/da7/namespacetesting_1_1internal_a19b35b39782d41e6ef76e1910a3a502e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constant Documentation\par
\pard\plain 
{\xe \v g_argvs\:testing::internal}
{\xe \v testing::internal\:g_argvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
::{\b std::vector}<{\b testing::internal::string}> testing::internal::g_argvs}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by GetArgvs(), and InitGoogleTestImpl().}\par
}
{\xe \v g_help_flag\:testing::internal}
{\xe \v testing::internal\:g_help_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::g_help_flag = false}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl(), and testing::internal::UnitTestImpl::RunAllTests().}\par
}
{\xe \v GTEST_ATTRIBUTE_UNUSED_\:testing::internal}
{\xe \v testing::internal\:GTEST_ATTRIBUTE_UNUSED_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
class {\b GTEST_API_} {\b testing::internal::ScopedTrace} testing::internal::GTEST_ATTRIBUTE_UNUSED_}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kAlsoRunDisabledTestsFlag\:testing::internal}
{\xe \v testing::internal\:kAlsoRunDisabledTestsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests"}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kBreakOnFailureFlag\:testing::internal}
{\xe \v testing::internal\:kBreakOnFailureFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kBreakOnFailureFlag[] = "break_on_failure"}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kCatchExceptionsFlag\:testing::internal}
{\xe \v testing::internal\:kCatchExceptionsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kCatchExceptionsFlag[] = "catch_exceptions"}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kColorEncodedHelpMessage\:testing::internal}
{\xe \v testing::internal\:kColorEncodedHelpMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kColorEncodedHelpMessage[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl().}\par
}
{\xe \v kColorFlag\:testing::internal}
{\xe \v testing::internal\:kColorFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kColorFlag[] = "color"}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kCurrentDirectoryString\:testing::internal}
{\xe \v testing::internal\:kCurrentDirectoryString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kCurrentDirectoryString[] = "./"}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::FilePath::GetCurrentDir(), and testing::internal::FilePath::RemoveFileName().}\par
}
{\xe \v kDeathTestStyleFlag\:testing::internal}
{\xe \v testing::internal\:kDeathTestStyleFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kDeathTestStyleFlag[] = "death_test_style"}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kDeathTestUseFork\:testing::internal}
{\xe \v testing::internal\:kDeathTestUseFork}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kDeathTestUseFork[] = "death_test_use_fork"}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kFilterFlag\:testing::internal}
{\xe \v testing::internal\:kFilterFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kFilterFlag[] = "filter"}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kFlagfileFlag\:testing::internal}
{\xe \v testing::internal\:kFlagfileFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kFlagfileFlag[] = "flagfile"}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlagsOnlyImpl().}\par
}
{\xe \v kInternalRunDeathTestFlag\:testing::internal}
{\xe \v testing::internal\:kInternalRunDeathTestFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kInternalRunDeathTestFlag[] = "internal_run_death_test"}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kListTestsFlag\:testing::internal}
{\xe \v testing::internal\:kListTestsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kListTestsFlag[] = "list_tests"}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kMaxBiggestInt\:testing::internal}
{\xe \v testing::internal\:kMaxBiggestInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b BiggestInt} testing::internal::kMaxBiggestInt}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
    ~({\cf17 static_cast<}BiggestInt{\cf17 >}(1) << (8*{\cf17 sizeof}(BiggestInt) - 1))\par
}
}
{\xe \v kMaxCodePoint1\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint1 = (static_cast<{\b UInt32}>(1) << 7) - 1}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by CodePointToUtf8().}\par
}
{\xe \v kMaxCodePoint2\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint2 = (static_cast<{\b UInt32}>(1) << (5 + 6)) - 1}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by CodePointToUtf8().}\par
}
{\xe \v kMaxCodePoint3\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint3 = (static_cast<{\b UInt32}>(1) << (4 + 2*6)) - 1}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by CodePointToUtf8().}\par
}
{\xe \v kMaxCodePoint4\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint4 = (static_cast<{\b UInt32}>(1) << (3 + 3*6)) - 1}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by CodePointToUtf8().}\par
}
{\xe \v kMaxRandomSeed\:testing::internal}
{\xe \v testing::internal\:kMaxRandomSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kMaxRandomSeed = 99999}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by GetNextRandomSeed(), and GetRandomSeedFromFlag().}\par
}
{\xe \v kOutputFlag\:testing::internal}
{\xe \v testing::internal\:kOutputFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kOutputFlag[] = "output"}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kPathSeparator\:testing::internal}
{\xe \v testing::internal\:kPathSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kPathSeparator = '/'}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::FilePath::ConcatPaths(), testing::internal::FilePath::FindLastPathSeparator(), IsPathSeparator(), and testing::internal::FilePath::Normalize().}\par
}
{\xe \v kPrintTimeFlag\:testing::internal}
{\xe \v testing::internal\:kPrintTimeFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kPrintTimeFlag[] = "print_time"}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kRandomSeedFlag\:testing::internal}
{\xe \v testing::internal\:kRandomSeedFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kRandomSeedFlag[] = "random_seed"}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kRepeatFlag\:testing::internal}
{\xe \v testing::internal\:kRepeatFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kRepeatFlag[] = "repeat"}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kShuffleFlag\:testing::internal}
{\xe \v testing::internal\:kShuffleFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kShuffleFlag[] = "shuffle"}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kStackTraceDepthFlag\:testing::internal}
{\xe \v testing::internal\:kStackTraceDepthFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kStackTraceDepthFlag[] = "stack_trace_depth"}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kStackTraceMarker\:testing::internal}
{\xe \v testing::internal\:kStackTraceMarker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} const char testing::internal::kStackTraceMarker = "\\nStack trace:\\n"}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::UnitTest::AddTestPartResult(), and testing::TestPartResult::ExtractSummary().}\par
}
{\xe \v kStdErrFileno\:testing::internal}
{\xe \v testing::internal\:kStdErrFileno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kStdErrFileno = STDERR_FILENO}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kStdOutFileno\:testing::internal}
{\xe \v testing::internal\:kStdOutFileno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kStdOutFileno = STDOUT_FILENO}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kStreamResultToFlag\:testing::internal}
{\xe \v testing::internal\:kStreamResultToFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kStreamResultToFlag[] = "stream_result_to"}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kTestTypeIdInGoogleTest\:testing::internal}
{\xe \v testing::internal\:kTestTypeIdInGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TypeId} testing::internal::kTestTypeIdInGoogleTest = {\b GetTestTypeId}(){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kThrowOnFailureFlag\:testing::internal}
{\xe \v testing::internal\:kThrowOnFailureFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kThrowOnFailureFlag[] = "throw_on_failure"}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by ParseGoogleTestFlag().}\par
}
{\xe \v kTypeParamLabel\:testing::internal}
{\xe \v testing::internal\:kTypeParamLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kTypeParamLabel[] = "TypeParam"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::ListTestsMatchingFilter(), testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart(), and PrintFullTestCommentIfPresent().}\par
}
{\xe \v kUnknownFile\:testing::internal}
{\xe \v testing::internal\:kUnknownFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kUnknownFile[] = "unknown file"}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by FormatCompilerIndependentFileLocation(), and FormatFileLocation().}\par
}
{\xe \v kValueParamLabel\:testing::internal}
{\xe \v testing::internal\:kValueParamLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kValueParamLabel[] = "GetParam()"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
Referenced by testing::internal::UnitTestImpl::ListTestsMatchingFilter(), and PrintFullTestCommentIfPresent().}\par
}
}